{"title":"PWN","uid":"5fc856885126d17b63352c1a2dc49ef9","slug":"HWS/2020/PWN","date":"2022-02-03T01:26:30.000Z","updated":"2022-02-03T07:48:40.060Z","comments":true,"path":"api/articles/HWS/2020/PWN.json","keywords":null,"cover":"/img/31.jpg","content":"<span id=\"more\"></span>\n\n<h1 id=\"栈利用\"><a href=\"#栈利用\" class=\"headerlink\" title=\"栈利用\"></a>栈利用</h1><h2 id=\"Linux保护技术概述\"><a href=\"#Linux保护技术概述\" class=\"headerlink\" title=\"Linux保护技术概述\"></a>Linux保护技术概述</h2><p>Linux常见的保护机制</p>\n<ul>\n<li>Canary：函数开始时向栈内插入canary值，返回时查询canary是否合法，以防止栈溢出（-fstack-protector 开启）</li>\n<li>Fortify：防止格式化字符串漏洞，包含%n的格式化字符串不能位于程序内存中的可写地址；使用位置参数时，必须使用范围内的所有参数，如果要使用%7<mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.452ex\" xmlns=\"http://www.w3.org/2000/svg\" width=\"15.548ex\" height=\"2.149ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 6872 950\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D465\" d=\"M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(572,0)\"><text data-variant=\"italic\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\" font-style=\"italic\">，</text></g><g data-mml-node=\"mi\" transform=\"translate(1472,0)\"><text data-variant=\"italic\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\" font-style=\"italic\">必</text></g><g data-mml-node=\"mi\" transform=\"translate(2372,0)\"><text data-variant=\"italic\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\" font-style=\"italic\">须</text></g><g data-mml-node=\"mi\" transform=\"translate(3272,0)\"><text data-variant=\"italic\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\" font-style=\"italic\">同</text></g><g data-mml-node=\"mi\" transform=\"translate(4172,0)\"><text data-variant=\"italic\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\" font-style=\"italic\">时</text></g><g data-mml-node=\"mi\" transform=\"translate(5072,0)\"><text data-variant=\"italic\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\" font-style=\"italic\">使</text></g><g data-mml-node=\"mi\" transform=\"translate(5972,0)\"><text data-variant=\"italic\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\" font-style=\"italic\">用</text></g></g></g></svg></mjx-container>1x-$6x</li>\n<li>NX/DEP：将数据虽在的内存页标识为不可执行，阻止执行shellcode（-z execstack 开启）</li>\n<li>PIE/ASLR：使得程序地址空间分布随机化，增加ROP利用难度（-pie-fPIC 开启）</li>\n<li>RELRO：设置符号重定向表为只读，并在程序启动时就解析并绑定所有动态符号，从而减少对GOT表的攻击（-z lazy/now 开启）</li>\n</ul>\n<h2 id=\"函数调用-退出时栈的变化\"><a href=\"#函数调用-退出时栈的变化\" class=\"headerlink\" title=\"函数调用/退出时栈的变化\"></a>函数调用/退出时栈的变化</h2><p>栈结构不在讲了，另一篇写了，提一下栈传参，在x86中函数参数直接保存到栈上，在x64中会先保存到六个寄存器里，寄存器用完再向栈保存</p>\n<p>调用函数时，栈的变化：</p>\n<ul>\n<li>首先执行call funcname 这一指令，其效果相当于两条指令，即先push retaddr（将下一条指令地址压栈，用于返回时的跳转）jmp xxx（跳转到函数去执行）</li>\n<li>然后push rbp（保存上一个栈的状态），mov rbp, rsp（把栈底抬上去），sub rsp, XXh（预留栈空间）</li>\n</ul>\n<p>函数退出时，栈的变化：</p>\n<ul>\n<li>执行leave指令，相当于两条指令，先mov rsp, rbp（把rsp压回去，退栈），pop rbp（恢复栈状态）</li>\n<li>执行ret指令，相当于pop rip（将之前压栈的返回地址还给rip继续执行）</li>\n</ul>\n<h3 id=\"栈溢出\"><a href=\"#栈溢出\" class=\"headerlink\" title=\"栈溢出\"></a>栈溢出</h3><p>向栈中写入变量超过了本身的执行限制，若写到了函数原本保存rip的位置，那么就可以控制程序执行</p>\n<h2 id=\"对抗DEP-NX保护\"><a href=\"#对抗DEP-NX保护\" class=\"headerlink\" title=\"对抗DEP/NX保护\"></a>对抗DEP/NX保护</h2><p>先从最基础的利用讲起</p>\n<h3 id=\"ret2text\"><a href=\"#ret2text\" class=\"headerlink\" title=\"ret2text\"></a>ret2text</h3><p>代码内本身有后门函数，可以控制rip返回到后门函数中</p>\n<h3 id=\"ret2shellcode\"><a href=\"#ret2shellcode\" class=\"headerlink\" title=\"ret2shellcode\"></a>ret2shellcode</h3><p>代码内一般是没有合适的代码，那么就需要手动写入shellcode，一般会有可以写入的在bss段的变量，写入之后通过栈溢出跳转到shellcode进行执行，关键是shellcode需要有可执行权限</p>\n<h3 id=\"ROP\"><a href=\"#ROP\" class=\"headerlink\" title=\"ROP\"></a>ROP</h3><p>有了NX保护之后，堆、栈、bss段都没有了可执行权限，可以通过ROP绕过，主要思想是在栈溢出的基础上，利用程序中已有的gadgets来改变某些寄存器或者变量的值，从而控制程序的执行流程。gadgets本质是以ret结尾的指令序列（因为ret本质相当于pop rip，而rip可以通过栈溢出修改）。</p>\n<p>利用条件：存在栈溢出能控制返回地址；可以找到满足条件的gadgets以及相应的gadgets地址</p>\n<p>利用方法(rop链)：精心设计栈结构，将多个gadgets用ret指令链接起来，构造执行</p>\n<h3 id=\"ret2libc\"><a href=\"#ret2libc\" class=\"headerlink\" title=\"ret2libc\"></a>ret2libc</h3><p>用got表泄漏libc地址然后找到system函数地址和/bin/sh地址劫持</p>\n<h2 id=\"对抗ASLR-PIE保护\"><a href=\"#对抗ASLR-PIE保护\" class=\"headerlink\" title=\"对抗ASLR/PIE保护\"></a>对抗ASLR/PIE保护</h2><p>如果需要跳转的目标函数(system)在程序中没有的话怎么办，事实是libc里啥函数都有，只要知道函数在libc的地址即可</p>\n<p>ASLR/PIE保护技术使得<strong>程序基地址</strong>和<strong>libc基地址</strong>每次加载的都不一样</p>\n<h3 id=\"延迟绑定机制\"><a href=\"#延迟绑定机制\" class=\"headerlink\" title=\"延迟绑定机制\"></a>延迟绑定机制</h3><p>在函数第一次被用到之后才进行绑定，执行一个dl_resolve的过程，将函数在libc里的真实地址填回到got表中</p>\n<h3 id=\"利用思路\"><a href=\"#利用思路\" class=\"headerlink\" title=\"利用思路\"></a>利用思路</h3><ul>\n<li>泄漏GOT表中某个函数的libc地址</li>\n<li>在libc中找到system, ‘/bin/sh’和上述函数的相对偏移</li>\n<li>得到system和’/bin/sh’的地址</li>\n<li>构造ROP链利用</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">终极偏移=libc基址+库内函数相对偏移\nsystem=libc基址+system在库内相对偏移\n'/bin/sh'=libc基址+'/bin/sh'在库内相对偏移<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>与上述ret2libc结合理解</p>\n<h2 id=\"对抗Canary保护\"><a href=\"#对抗Canary保护\" class=\"headerlink\" title=\"对抗Canary保护\"></a>对抗Canary保护</h2><p>回忆一下栈结构，canary相当于在函数栈帧和rbp之间插入了canary，要覆盖rbp和rip一定会覆盖掉canary，函数在结束时会检查canary的值以判断是否溢出</p>\n<h3 id=\"对抗方法\"><a href=\"#对抗方法\" class=\"headerlink\" title=\"对抗方法\"></a>对抗方法</h3><ul>\n<li>泄漏canary值：</li>\n<li>泄漏或覆盖fs:28h内的值（fs:28h就是验证时对比的值）</li>\n<li>劫持stack_chk_fail函数（修改GOT表中存储的stack_chk_fail地址）</li>\n<li>stack smashing：__stack_chk_fail函数会打印出argv[0]，可以用其泄漏内存地址信息</li>\n<li>逐字节爆破（BROP）：需要确定程序重启后canary不变</li>\n</ul>\n<h4 id=\"BROP\"><a href=\"#BROP\" class=\"headerlink\" title=\"BROP\"></a>BROP</h4><p>1.判断栈溢出长度：可以暴力枚举，找到程序崩溃的长度</p>\n<p>2.逐字节爆破canary：变动canary的逐个字节，爆破出canary</p>\n<p>3.寻找stop gadget：改变返回地址之后，执行跳到了某个等待输入的区域，称这一区域为stop gadget，可以通过爆破找到stop gadget。（可以将所有的dead位置替换为stop gadget，便于调试）</p>\n<p>4.寻找useful gadget：可以操作寄存器的gadget</p>\n<p>5.寻找可用的PLT表项：</p>\n<p>6.利用PLT表中的puts函数，配合useful gadget来远程dump信息</p>\n<h2 id=\"栈利用拓展\"><a href=\"#栈利用拓展\" class=\"headerlink\" title=\"栈利用拓展\"></a>栈利用拓展</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>溢出长度不足？在bss段等已知位置进行写入，提前进行栈布局，然后通过覆盖栈上存储的saved rbp和saved rip把栈劫持到写入位置，关键是把rsp的值劫持到写入位置</p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>SROP：没有PLT表，利用sigreturn系统调用（控制栈指针，将原来的rip指向syscall gadget换成syscall; ret gadgeet）</p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Windows canary：可以算出来canary=__security_cookie ^ ebp，学习Windows的异常处理结构</p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>linux内核：linux内核的保护机制更多，限制也更多，例如SMEP（类似于NX）</p></blockquote>\n<h3 id=\"ret2user（内核栈溢出）\"><a href=\"#ret2user（内核栈溢出）\" class=\"headerlink\" title=\"ret2user（内核栈溢出）\"></a>ret2user（内核栈溢出）</h3><p>在没有保护的情况下，直接将返回地址覆盖为用户态调用commit_cres(prepare_kernel_cred(0));的函数的地址进行提权，然后使用iretq指令从内核态返回用户态从而getshell。</p>\n<p>开启了SMEP，没有开启KALSR、canary，可以构造ROP，有两种思路：1.利用ROP直接执行commit_cres(prepare_kernel_cred(0));然后iret返回用户空间。2.利用ROP设置cr4寄存器，关闭smep，进行ret2user攻击。</p>\n<h2 id=\"格式化字符串漏洞\"><a href=\"#格式化字符串漏洞\" class=\"headerlink\" title=\"格式化字符串漏洞\"></a>格式化字符串漏洞</h2><p>主要是printf函数家族的问题，这些格式化字符串函数可以接受可变数量的参数，并将第一个参数作为格式化字符串，根据其来解析之后的函数</p>\n<p>正常例子</p>\n<pre class=\"line-numbers language-C\" data-language=\"C\"><code class=\"language-C\">printf(\"Color %s, Number %d, Float %.42f\", \"red\", 123456, 3.14);\n//output: Color red, Number 123456, Float 3.14<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>重要特性：printf()函数的参数个数不确定，将其分为两部分（第一个参数为参数中的格式化字符串的数目决定了后续的参数个数）</p></blockquote>\n<p>注意参数的入栈顺序，是从函数最右边的参数开始入栈，比如上述例子，最先入栈的参数是3.14，最后入栈的是格式化字符串</p>\n<p>若第一个参数被控制，那么可以输入任意个参数，从而可以将内存(栈)中的其他量打印出来，可以用此泄漏栈信息</p>\n<p>结合%s利用：%s是将对应的参数当做一个地址来解析，输出其地址对应的数据，结合%s可以进行任意地址信息泄漏</p>\n<p>结合%n利用：%n是把前面已经输出的长度写入某个内存地址，利用%n可以向内存中写入值，（方便起见可以用宽度字符%.100d这样的来填充长度）</p>\n<pre class=\"line-numbers language-C\" data-language=\"C\"><code class=\"language-C\">int num=66666666;\nprintf(\"Before: num=%d\\n\", num);//Before: num=66666666\nprintf(\"%d%n\\n\", num, &amp;num);//66666666\nprintf(\"After:num=%d\\n\", num);//After:num=8(之前输出的长度为8)\n//%.100d%n的使用\n//%11$n=%x%x%x%x%x%x%x%x%x%x%n\n//%n:dword:4bytes; %hn:word:2bytes; %hhn:byte:1bytes<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"利用例子\"><a href=\"#利用例子\" class=\"headerlink\" title=\"利用例子\"></a>利用例子</h3><p>把0x6a686664写入地址0x08045566</p>\n<p>payload如下</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\\x66\\x55\\x04\\x08\\x67\\x55\\x04\\x08 //向四个地址输入，小端序\n\\x68\\x55\\x04\\x08\\x69\\x55\\x04\\x08\n%84c%4$hhn //此时之前四个地址已经16个字节，再输出84个字节，即可对其100个字节，那么输入的值就是0x64(十进制100)\n%2c%5$hhn //再加二，输入0x66，若小余0x64，可以溢出0xff，因为hhn只能输出后1bytes，故溢出的会丢弃\n%2c%6$hhn\n%2c%7$hhn<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"Fortify保护\"><a href=\"#Fortify保护\" class=\"headerlink\" title=\"Fortify保护\"></a>Fortify保护</h3><p>主要用来防止格式化字符串，如果要使用%7<mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.452ex\" xmlns=\"http://www.w3.org/2000/svg\" width=\"15.548ex\" height=\"2.149ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 6872 950\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D465\" d=\"M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(572,0)\"><text data-variant=\"italic\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\" font-style=\"italic\">，</text></g><g data-mml-node=\"mi\" transform=\"translate(1472,0)\"><text data-variant=\"italic\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\" font-style=\"italic\">必</text></g><g data-mml-node=\"mi\" transform=\"translate(2372,0)\"><text data-variant=\"italic\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\" font-style=\"italic\">须</text></g><g data-mml-node=\"mi\" transform=\"translate(3272,0)\"><text data-variant=\"italic\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\" font-style=\"italic\">同</text></g><g data-mml-node=\"mi\" transform=\"translate(4172,0)\"><text data-variant=\"italic\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\" font-style=\"italic\">时</text></g><g data-mml-node=\"mi\" transform=\"translate(5072,0)\"><text data-variant=\"italic\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\" font-style=\"italic\">使</text></g><g data-mml-node=\"mi\" transform=\"translate(5972,0)\"><text data-variant=\"italic\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\" font-style=\"italic\">用</text></g></g></g></svg></mjx-container>-%6$</p>\n<h2 id=\"dl-runtime-resolve高级利用\"><a href=\"#dl-runtime-resolve高级利用\" class=\"headerlink\" title=\"dl_runtime_resolve高级利用\"></a>dl_runtime_resolve高级利用</h2><p>ret2_dl_runtime_resolve，只需要可执行程序，不依赖libc的攻击手法</p>\n<h3 id=\"ELF基本结构\"><a href=\"#ELF基本结构\" class=\"headerlink\" title=\"ELF基本结构\"></a>ELF基本结构</h3><p>ELF由ELF头，程序头部表和其对应的段，节区头部表和其对应的节组成。若elf文件参与了动态链接，它的程序头部表将包含类型为PT_DYNAMIC的段，它包含.dynamic节区，结构如下</p>\n<pre class=\"line-numbers language-C\" data-language=\"C\"><code class=\"language-C\">typedef struct {\n\tElf32_Sword d_tag;\n\tunion{\n\t\tElf32_Word d_val;\n\t\tElf32_Addr d_ptr;\n\t} d_un;\n}Elf32_Dyn;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>其中tag对应着每个节区，比如JMPREL对应着.rel.plt节区；节区中包含目标文件的所有信息，其中类型为REL的节区包含重定位表项；.rel.plt用于函数重定位，.rel.dyn用于变量重定位</p>\n<p>首先用r_info这个信息，算出函数在dynsum结构体里的偏移，而r_offset是got表的偏移，</p>\n<p>听不懂了，一堆结构体乱指乱引用太长了捋不清，就不记了，等什么时候再见再说吧</p>\n<h3 id=\"漏洞利用流程\"><a href=\"#漏洞利用流程\" class=\"headerlink\" title=\"漏洞利用流程\"></a>漏洞利用流程</h3><ul>\n<li>控制EIP为PLT[0]的位置们只需传递一个index_arg参数</li>\n<li>控制index_arg的大小，使reloc的位置落在可控地址内</li>\n<li>伪造reloc内容，使sym落在可控地址内</li>\n<li>伪造sym内容，使name落在可控地址内</li>\n<li>伪造name为任意库函数名称，如system</li>\n</ul>\n","feature":true,"text":" 栈利用Linux保护技术概述Linux常见的保护机制 Canary：函数开始时向栈内插入canary值，返回时查询canary是否合法，以防止栈溢出（-fstack-protector 开启） Fortify：防止格式化字符串漏洞，包含%n的格式化字符串不能位于程序内存中的可写...","link":"","photos":[],"count_time":{"symbolsCount":"4.4k","symbolsTime":"4 mins."},"categories":[{"name":"HWS","slug":"HWS","count":2,"path":"api/categories/HWS.json"}],"tags":[{"name":"HWS 2020","slug":"HWS-2020","count":2,"path":"api/tags/HWS-2020.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%A0%88%E5%88%A9%E7%94%A8\"><span class=\"toc-text\">栈利用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Linux%E4%BF%9D%E6%8A%A4%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">Linux保护技术概述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8-%E9%80%80%E5%87%BA%E6%97%B6%E6%A0%88%E7%9A%84%E5%8F%98%E5%8C%96\"><span class=\"toc-text\">函数调用&#x2F;退出时栈的变化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%88%E6%BA%A2%E5%87%BA\"><span class=\"toc-text\">栈溢出</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E6%8A%97DEP-NX%E4%BF%9D%E6%8A%A4\"><span class=\"toc-text\">对抗DEP&#x2F;NX保护</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ret2text\"><span class=\"toc-text\">ret2text</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ret2shellcode\"><span class=\"toc-text\">ret2shellcode</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ROP\"><span class=\"toc-text\">ROP</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ret2libc\"><span class=\"toc-text\">ret2libc</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E6%8A%97ASLR-PIE%E4%BF%9D%E6%8A%A4\"><span class=\"toc-text\">对抗ASLR&#x2F;PIE保护</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">延迟绑定机制</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">利用思路</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E6%8A%97Canary%E4%BF%9D%E6%8A%A4\"><span class=\"toc-text\">对抗Canary保护</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E6%8A%97%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">对抗方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#BROP\"><span class=\"toc-text\">BROP</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A0%88%E5%88%A9%E7%94%A8%E6%8B%93%E5%B1%95\"><span class=\"toc-text\">栈利用拓展</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ret2user%EF%BC%88%E5%86%85%E6%A0%B8%E6%A0%88%E6%BA%A2%E5%87%BA%EF%BC%89\"><span class=\"toc-text\">ret2user（内核栈溢出）</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E\"><span class=\"toc-text\">格式化字符串漏洞</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%A9%E7%94%A8%E4%BE%8B%E5%AD%90\"><span class=\"toc-text\">利用例子</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Fortify%E4%BF%9D%E6%8A%A4\"><span class=\"toc-text\">Fortify保护</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#dl-runtime-resolve%E9%AB%98%E7%BA%A7%E5%88%A9%E7%94%A8\"><span class=\"toc-text\">dl_runtime_resolve高级利用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ELF%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">ELF基本结构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">漏洞利用流程</span></a></li></ol></li></ol></li></ol>","author":{"name":"S1eepy","slug":"blog-author","avatar":"/img/touxiang.jpg","link":"/","description":"Someone who is learning how to take life seriously","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"DNS隐蔽信道综述","uid":"c4f987dd8b0d0b7837851ac5e86e8a3e","slug":"Research/Paper/DNS隐蔽信道综述","date":"2022-02-02T11:32:39.000Z","updated":"2022-02-02T14:18:44.374Z","comments":true,"path":"api/articles/Research/Paper/DNS隐蔽信道综述.json","keywords":null,"cover":"/img/30.jpg","text":" DNS隐蔽信道综述本篇写为阅读《DNS隐蔽信道综述》的笔记，由于DNS以及DNS隧道相关内容在另一篇已经写过，就尽量减少重复了，可能有部分内容会减少提及。 DNS隐蔽信道（DNS covert channel，DCC） 本文贡献1.对DCC的威胁模型进行了归类总结；对DCC的发...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"Research/Paper","slug":"Research-Paper","count":2,"path":"api/categories/Research-Paper.json"}],"tags":[{"name":"Research Paper","slug":"Research-Paper","count":2,"path":"api/tags/Research-Paper.json"}],"author":{"name":"S1eepy","slug":"blog-author","avatar":"/img/touxiang.jpg","link":"/","description":"Someone who is learning how to take life seriously","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}