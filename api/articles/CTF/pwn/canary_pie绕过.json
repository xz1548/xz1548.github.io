{"title":"canary_pie绕过","uid":"5cbed18fc0178c7e2f7d933895162e2e","slug":"CTF/pwn/canary_pie绕过","date":"2022-01-18T11:53:50.000Z","updated":"2022-01-19T07:55:48.512Z","comments":true,"path":"api/articles/CTF/pwn/canary_pie绕过.json","keywords":null,"cover":"/img/22.jpg","content":"<span id=\"more\"></span>\n\n<h1 id=\"Canary-pie绕过\"><a href=\"#Canary-pie绕过\" class=\"headerlink\" title=\"Canary_pie绕过\"></a>Canary_pie绕过</h1><h2 id=\"Canary机制介绍\"><a href=\"#Canary机制介绍\" class=\"headerlink\" title=\"Canary机制介绍\"></a>Canary机制介绍</h2><p>canary是一种用来防护栈溢出的保护机制，原理是先在函数的入口处，从fs/gs寄存器中取出一个4字节或者8字节的值存到栈上，当程序结束后再检查这个值是否和存进去的值一致</p>\n<h2 id=\"Canary-bypass\"><a href=\"#Canary-bypass\" class=\"headerlink\" title=\"Canary bypass\"></a>Canary bypass</h2><p>只要保持canary值不变，依旧可以修改eip的值</p>\n<h3 id=\"格式化字符串绕过canary\"><a href=\"#格式化字符串绕过canary\" class=\"headerlink\" title=\"格式化字符串绕过canary\"></a>格式化字符串绕过canary</h3><p>通过格式化字符串读取canary的值</p>\n<h4 id=\"格式化字符串\"><a href=\"#格式化字符串\" class=\"headerlink\" title=\"格式化字符串\"></a>格式化字符串</h4><p>C语言的printf函数一般是这么用printf(“%s”, str);这时str的内容就会被打印出来，%s就是所说的格式化字符串，将变量中的内容按照格式化字符串的规定打印出来，由于%s判断字符串结束的依据是结尾的\\x00，因此可以把输入和canary连接在一起，将canary一起打印出来。需要注意的是canary的最后一位一定时\\x00，用于防止连带输出，所以我们改的时候要把canary的最后一位也改了</p>\n<h4 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h4><p>canary bypass</p>\n<h3 id=\"canary爆破\"><a href=\"#canary爆破\" class=\"headerlink\" title=\"canary爆破\"></a>canary爆破</h3><p>程序中必须有fork函数，不断自我复制，我们可以逐位爆破，若报错则说明这一位不对，若可以接着跑下一位就能一直跑最后得出正确的canary</p>\n<h3 id=\"Stack-smashing\"><a href=\"#Stack-smashing\" class=\"headerlink\" title=\"Stack smashing\"></a>Stack smashing</h3><p>故意触发canary_ssp leak</p>\n<h3 id=\"劫持-stack-chk-fail\"><a href=\"#劫持-stack-chk-fail\" class=\"headerlink\" title=\"劫持__stack_chk_fail\"></a>劫持__stack_chk_fail</h3><p>通过程序中的其他函数，修改got表中的__stack_chk_fail函数地址，在栈溢出后执行该函数，然后就会跳到我们想要执行的函数</p>\n<h2 id=\"PIE机制介绍\"><a href=\"#PIE机制介绍\" class=\"headerlink\" title=\"PIE机制介绍\"></a>PIE机制介绍</h2><p>PIE是一个针对代码段(.text)，数据段(.data)，未初始化全局变量段(.bss)等固定地址的一个防护技术，如果程序开启了PIE保护，那么每次程序加载的时候都会变换加载地址，从而不能通过ROPgadget等工具解题</p>\n<h2 id=\"PIE-bypass\"><a href=\"#PIE-bypass\" class=\"headerlink\" title=\"PIE bypass\"></a>PIE bypass</h2><p>对于开启了PIE保护的程序，所有代码段的地址都只有最后三个数是已知的，而程序加载地址一般都是以内存页为单位的，所以程序的基地址最后三个数字一定是0，也就是那些地址已知的最后三个数就是实际地址的最后三个数。根据此，虽然我们没有完整地址，但是只要我们指导最后三个数，就可以利用栈上已有的地址，只修改最后两个字节，即可绕过。</p>\n<p>对于绕过PIE保护的核心思想就是partial writing</p>\n<h4 id=\"例题-1\"><a href=\"#例题-1\" class=\"headerlink\" title=\"例题\"></a>例题</h4>","text":" Canary_pie绕过Canary机制介绍canary是一种用来防护栈溢出的保护机制，原理是先在函数的入口处，从fs/gs寄存器中取出一个4字节或者8字节的值存到栈上，当程序结束后再检查这个值是否和存进去的值一致 Canary bypass只要保持canary值不变，依旧可以...","link":"","photos":[],"count_time":{"symbolsCount":928,"symbolsTime":"1 mins."},"categories":[{"name":"CTF/PWN","slug":"CTF-PWN","count":7,"path":"api/categories/CTF-PWN.json"}],"tags":[{"name":"CTF PWN","slug":"CTF-PWN","count":6,"path":"api/tags/CTF-PWN.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Canary-pie%E7%BB%95%E8%BF%87\"><span class=\"toc-text\">Canary_pie绕过</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Canary%E6%9C%BA%E5%88%B6%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">Canary机制介绍</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Canary-bypass\"><span class=\"toc-text\">Canary bypass</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%95%E8%BF%87canary\"><span class=\"toc-text\">格式化字符串绕过canary</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2\"><span class=\"toc-text\">格式化字符串</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BE%8B%E9%A2%98\"><span class=\"toc-text\">例题</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#canary%E7%88%86%E7%A0%B4\"><span class=\"toc-text\">canary爆破</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Stack-smashing\"><span class=\"toc-text\">Stack smashing</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8A%AB%E6%8C%81-stack-chk-fail\"><span class=\"toc-text\">劫持__stack_chk_fail</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#PIE%E6%9C%BA%E5%88%B6%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">PIE机制介绍</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#PIE-bypass\"><span class=\"toc-text\">PIE bypass</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BE%8B%E9%A2%98-1\"><span class=\"toc-text\">例题</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"S1eepy","slug":"blog-author","avatar":"/img/touxiang.jpg","link":"/","description":"Someone who is learning how to take life seriously","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"ret2xx","uid":"e75c21f70c678b134f6a0bde8c339180","slug":"CTF/pwn/ret2xx","date":"2022-01-18T11:55:26.000Z","updated":"2022-01-20T04:45:01.559Z","comments":true,"path":"api/articles/CTF/pwn/ret2xx.json","keywords":null,"cover":"/img/21.jpg","text":" ret2xx什么是ret2xx泛指ret2text，ret2shellcode，ret2syscall，ret2libc，ret2csu，其中ret2是return to的谐音，可以使用利用eip指针的方法来获取权限 ROPReturn Oriented Programming...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"CTF/PWN","slug":"CTF-PWN","count":7,"path":"api/categories/CTF-PWN.json"}],"tags":[{"name":"CTF PWN","slug":"CTF-PWN","count":6,"path":"api/tags/CTF-PWN.json"}],"author":{"name":"S1eepy","slug":"blog-author","avatar":"/img/touxiang.jpg","link":"/","description":"Someone who is learning how to take life seriously","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"RE-BUU","uid":"ce6a61e69eea25b26a44cdf9f84d23a7","slug":"CTF/reverse/RE-BUU","date":"2022-01-18T07:17:52.000Z","updated":"2022-01-22T08:42:24.375Z","comments":true,"path":"api/articles/CTF/reverse/RE-BUU.json","keywords":null,"cover":"/img/18.jpg","text":" BUUCTF-Reverse刷题记录新年快乐一个upx壳，怎么看出来的还不知道，等回头学会了再补 直接upx -d去壳，扔进idaF5看代码就是比较输入字符串和”HappyNewYear!”，因此这个字符串就是flag xor主函数是逻辑如下，遍历输入字符串，将当前位与前一位异...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"CTF/REVERSE","slug":"CTF-REVERSE","count":2,"path":"api/categories/CTF-REVERSE.json"}],"tags":[{"name":"CTF REVERSE","slug":"CTF-REVERSE","count":2,"path":"api/tags/CTF-REVERSE.json"}],"author":{"name":"S1eepy","slug":"blog-author","avatar":"/img/touxiang.jpg","link":"/","description":"Someone who is learning how to take life seriously","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}