{"title":"栈溢出基础","uid":"b0e5183f9443ee80e444d03488f07c6f","slug":"CTF/pwn/栈溢出基础","date":"2022-01-18T04:54:11.000Z","updated":"2022-01-18T04:55:01.853Z","comments":true,"path":"api/articles/CTF/pwn/栈溢出基础.json","keywords":null,"cover":[],"content":"<span id=\"more\"></span>\n\n<h1 id=\"栈溢出基础\"><a href=\"#栈溢出基础\" class=\"headerlink\" title=\"栈溢出基础\"></a>栈溢出基础</h1><h2 id=\"C语言函数调用栈\"><a href=\"#C语言函数调用栈\" class=\"headerlink\" title=\"C语言函数调用栈\"></a>C语言函数调用栈</h2><p>栈是程序运行时一块连续的内存区域，用来保存函数运行时的状态信息，包括函数的局部变量等</p>\n<p>当发生函数调用时，调用函数(caller)的状态被保存在栈内，被调用函数(callee)的状态被压入调用栈的栈顶</p>\n<p>函数调用结束时栈顶的函数(callee)状态被弹出，栈顶恢复到调用函数(caller)的状态</p>\n<p>函数调用栈的内存中从高地址到低地址生长，所以栈顶内存地址在压栈时变小，退栈时变大</p>\n<h3 id=\"寄存器\"><a href=\"#寄存器\" class=\"headerlink\" title=\"寄存器\"></a>寄存器</h3><ul>\n<li>eip寄存器：下一条要被执行的指令，它所指向的指令</li>\n<li>esp寄存器：保存调用栈的栈顶地址</li>\n<li>ebp寄存器：保存当前函数状态基地址</li>\n</ul>\n<h3 id=\"函数调用过程\"><a href=\"#函数调用过程\" class=\"headerlink\" title=\"函数调用过程\"></a>函数调用过程</h3><p>先把参数压入栈</p>\n<p>然后将调用函数(caller)的下一条指令的地址作为被调用函数(callee)的返回地址压入栈中</p>\n<p>再将ebp的值压入栈，并将ebp寄存器的值更新为当前栈顶的地址，这样caller的ebp信息得以保存，同时ebp被更新为callee的基地址</p>\n<p>最后是将callee的局部变量等数据压入栈（栈溢出最经常出现的位置）</p>\n<p><img src=\"img/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80_img/image-20220116174849502.png\" alt=\"image-20220116174849502\"></p>\n<h3 id=\"函数调用结束恢复过程\"><a href=\"#函数调用结束恢复过程\" class=\"headerlink\" title=\"函数调用结束恢复过程\"></a>函数调用结束恢复过程</h3><p>变化的核心任务是丢弃callee的状态，将栈顶恢复到caller的过程</p>\n<p>首先将局部变量从栈顶弹出，栈顶会恢复到callee的基地址</p>\n<p>然后caller的基地址从栈顶弹出，存到ebp内，这样caller的ebp信息得以恢复，此时栈顶指向返回地址</p>\n<p>再将返回地址从栈内弹出，存到eip寄存器内，这样caller的eip信息得以恢复</p>\n<h2 id=\"栈溢出原理\"><a href=\"#栈溢出原理\" class=\"headerlink\" title=\"栈溢出原理\"></a>栈溢出原理</h2><p>从上面可以看出，caller的eip完全是由返回地址控制的，只要想办法在写入局部变量时控制长度，写入到返回地址处，就能够让caller的eip调到其他地方，从而getshell</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>缓冲区溢出：本质是向定长的缓冲区写入了超长的数据，从而导致数据覆盖了合法内存，包括栈溢出，堆溢出，data段溢出等</p></blockquote>\n<h2 id=\"栈溢出基本利用\"><a href=\"#栈溢出基本利用\" class=\"headerlink\" title=\"栈溢出基本利用\"></a>栈溢出基本利用</h2>","feature":true,"text":" 栈溢出基础C语言函数调用栈栈是程序运行时一块连续的内存区域，用来保存函数运行时的状态信息，包括函数的局部变量等 当发生函数调用时，调用函数(caller)的状态被保存在栈内，被调用函数(callee)的状态被压入调用栈的栈顶 函数调用结束时栈顶的函数(callee)状态被弹出，...","link":"","photos":[],"count_time":{"symbolsCount":781,"symbolsTime":"1 mins."},"categories":[{"name":"CTF/PWN","slug":"CTF-PWN","count":3,"path":"api/categories/CTF-PWN.json"}],"tags":[{"name":"CTF PWN","slug":"CTF-PWN","count":3,"path":"api/tags/CTF-PWN.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%A0%88%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80\"><span class=\"toc-text\">栈溢出基础</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88\"><span class=\"toc-text\">C语言函数调用栈</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%84%E5%AD%98%E5%99%A8\"><span class=\"toc-text\">寄存器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">函数调用过程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BB%93%E6%9D%9F%E6%81%A2%E5%A4%8D%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">函数调用结束恢复过程</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">栈溢出原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A0%88%E6%BA%A2%E5%87%BA%E5%9F%BA%E6%9C%AC%E5%88%A9%E7%94%A8\"><span class=\"toc-text\">栈溢出基本利用</span></a></li></ol></li></ol>","author":{"name":"S1eepy","slug":"blog-author","avatar":"/img/touxiang.jpg","link":"/","description":"Why So S1eepy","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"shellcode","uid":"33178a053863ba406bb965eb7a776aab","slug":"CTF/pwn/shellcode","date":"2022-01-18T04:55:28.000Z","updated":"2022-01-18T04:55:54.803Z","comments":true,"path":"api/articles/CTF/pwn/shellcode.json","keywords":null,"cover":null,"text":" shellcode什么是shellcode软件漏洞利用过程中使用一小段机器代码 启动shell进行交互 可能存在的问题shellcode只允许输入十几个字节 无法调用系统函数(不知道system的地址) 解决触发中断（0x80或者syscall） 如何编写shellcode32...","link":"","photos":[],"count_time":{"symbolsCount":896,"symbolsTime":"1 mins."},"categories":[{"name":"CTF/PWN","slug":"CTF-PWN","count":3,"path":"api/categories/CTF-PWN.json"}],"tags":[{"name":"CTF PWN","slug":"CTF-PWN","count":3,"path":"api/tags/CTF-PWN.json"}],"author":{"name":"S1eepy","slug":"blog-author","avatar":"/img/touxiang.jpg","link":"/","description":"Why So S1eepy","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Learn_RE","uid":"a100591a1cf0e28185d19ee6ce40ac1f","slug":"CTF/reverse/Learn_RE","date":"2022-01-18T04:52:25.000Z","updated":"2022-01-18T04:52:58.773Z","comments":true,"path":"api/articles/CTF/reverse/Learn_RE.json","keywords":null,"cover":null,"text":" RE学习笔记记录一下寒假期间学习RE的知识 ","link":"","photos":[],"count_time":{"symbolsCount":24,"symbolsTime":"1 mins."},"categories":[{"name":"CTF/REVERSE","slug":"CTF-REVERSE","count":2,"path":"api/categories/CTF-REVERSE.json"}],"tags":[{"name":"CTF REVERSE","slug":"CTF-REVERSE","count":2,"path":"api/tags/CTF-REVERSE.json"}],"author":{"name":"S1eepy","slug":"blog-author","avatar":"/img/touxiang.jpg","link":"/","description":"Why So S1eepy","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}